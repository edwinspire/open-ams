"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var findDisplayed_1 = require("./lib/findDisplayed");
var fs = require("fs");
var Locator_1 = require("./lib/Locator");
var waitForDeleted_1 = require("./lib/waitForDeleted");
var util_1 = require("./lib/util");
var Task_1 = require("@dojo/core/async/Task");
var JSZip = require("jszip");
var path_1 = require("path");
var Element = (function (_super) {
    tslib_1.__extends(Element, _super);
    function Element(elementId, session) {
        var _this = _super.call(this) || this;
        _this._elementId =
            elementId.ELEMENT ||
                elementId.elementId ||
                elementId['element-6066-11e4-a52e-4f735466cecf'] ||
                elementId;
        _this._session = session;
        return _this;
    }
    Object.defineProperty(Element.prototype, "elementId", {
        get: function () {
            return this._elementId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "session", {
        get: function () {
            return this._session;
        },
        enumerable: true,
        configurable: true
    });
    Element.prototype._get = function (path, requestData, pathParts) {
        path = 'element/' + encodeURIComponent(this._elementId) + '/' + path;
        return this._session.serverGet(path, requestData, pathParts);
    };
    Element.prototype._post = function (path, requestData, pathParts) {
        path = 'element/' + encodeURIComponent(this._elementId) + '/' + path;
        return this._session.serverPost(path, requestData, pathParts);
    };
    Element.prototype.toJSON = function () {
        return { ELEMENT: this._elementId };
    };
    Element.prototype._normalizeWhitespace = function (text) {
        if (text) {
            text = text
                .replace(/^\s+/gm, '')
                .replace(/\s+$/gm, '')
                .replace(/\s*\r\n\s*/g, '\n')
                .replace(/ +/g, ' ');
        }
        return text;
    };
    Element.prototype._uploadFile = function (filename) {
        var _this = this;
        return new Task_1.default(function (resolve) {
            var content = fs.readFileSync(filename);
            var zip = new JSZip();
            zip.file(path_1.basename(filename), content);
            zip.generateAsync({ type: 'base64' }).then(function (file) {
                resolve(_this.session.serverPost('file', { file: file }));
            });
        });
    };
    Element.prototype.find = function (using, value) {
        var session = this._session;
        var capabilities = session.capabilities;
        if (capabilities.usesWebDriverLocators) {
            var locator = Locator_1.toW3cLocator(using, value);
            using = locator.using;
            value = locator.value;
        }
        if (using.indexOf('link text') !== -1 &&
            (capabilities.brokenWhitespaceNormalization ||
                capabilities.brokenLinkTextLocator)) {
            return session
                .execute(session['_manualFindByLinkText'], [using, value, false, this])
                .then(function (element) {
                if (!element) {
                    var error = new Error();
                    error.name = 'NoSuchElement';
                    throw error;
                }
                return new Element(element, session);
            });
        }
        return this._post('element', {
            using: using,
            value: value
        })
            .then(function (element) {
            return new Element(element, session);
        })
            .catch(function (error) {
            if (error.name === 'UnknownCommand' &&
                error.message.indexOf('Unable to locate element:') !== -1) {
                var newError = new Error();
                newError.name = 'NoSuchElement';
                newError.message = error.message;
                throw newError;
            }
            throw error;
        });
    };
    Element.prototype.findAll = function (using, value) {
        var session = this._session;
        var capabilities = session.capabilities;
        if (capabilities.usesWebDriverLocators) {
            var locator = Locator_1.toW3cLocator(using, value);
            using = locator.using;
            value = locator.value;
        }
        var task;
        if (using.indexOf('link text') !== -1 &&
            (capabilities.brokenWhitespaceNormalization ||
                capabilities.brokenLinkTextLocator)) {
            task = session.execute(session['_manualFindByLinkText'], [
                using,
                value,
                true,
                this
            ]);
        }
        else {
            task = this._post('elements', {
                using: using,
                value: value
            });
        }
        return task.then(function (elements) {
            return elements.map(function (element) {
                return new Element(element, session);
            });
        });
    };
    Element.prototype.click = function () {
        var _this = this;
        if (this.session.capabilities.brokenClick) {
            return this.session.execute(function (element) {
                element.click();
            }, [this]);
        }
        return this._post('click').then(function () {
            if (_this.session.capabilities.touchEnabled ||
                _this.session.capabilities.returnsFromClickImmediately) {
                return util_1.sleep(500);
            }
        });
    };
    Element.prototype.submit = function () {
        if (this.session.capabilities.brokenSubmitElement) {
            return this.session.execute(function (element) {
                if (element.submit) {
                    element.submit();
                }
                else if (element.type === 'submit' && element.click) {
                    element.click();
                }
            }, [this]);
        }
        return this._post('submit');
    };
    Element.prototype.getVisibleText = function () {
        var _this = this;
        var result = this._get('text');
        if (this.session.capabilities.brokenWhitespaceNormalization) {
            return result.then(function (text) { return _this._normalizeWhitespace(text); });
        }
        return result;
    };
    Element.prototype.type = function (value) {
        var _this = this;
        var getPostData = function (value) {
            if (_this.session.capabilities.usesFlatKeysArray) {
                return { value: value.join('').split('') };
            }
            return { value: value };
        };
        if (!Array.isArray(value)) {
            value = [value];
        }
        if (this.session.capabilities.remoteFiles) {
            var filename = value.join('');
            try {
                if (fs.statSync(filename).isFile()) {
                    return this._uploadFile(filename).then(function (uploadedFilename) {
                        return _this._post('value', getPostData([uploadedFilename])).then(noop);
                    });
                }
            }
            catch (error) {
            }
        }
        return this._post('value', getPostData(value)).then(noop);
    };
    Element.prototype.getTagName = function () {
        var _this = this;
        return this._get('name').then(function (name) {
            if (_this.session.capabilities.brokenHtmlTagName) {
                return _this.session
                    .execute('return document.body && document.body.tagName === document.body.tagName.toUpperCase();')
                    .then(function (isHtml) {
                    return isHtml ? name.toLowerCase() : name;
                });
            }
            return name;
        });
    };
    Element.prototype.clearValue = function () {
        return this._post('clear').then(noop);
    };
    Element.prototype.isSelected = function () {
        return this._get('selected');
    };
    Element.prototype.isEnabled = function () {
        return this._get('enabled');
    };
    Element.prototype.getSpecAttribute = function (name) {
        var _this = this;
        return this._get('attribute/$0', null, [name])
            .then(function (value) {
            if (_this.session.capabilities.brokenNullGetSpecAttribute &&
                (value === '' || value === undefined)) {
                return _this.session
                    .execute(function (element, name) {
                    return element.hasAttribute(name);
                }, [_this, name])
                    .then(function (hasAttribute) {
                    return hasAttribute ? value : null;
                });
            }
            return value || null;
        })
            .then(function (value) {
            if (typeof value === 'boolean') {
                value = value ? 'true' : null;
            }
            return value;
        });
    };
    Element.prototype.getAttribute = function (name) {
        return this.session.execute('return arguments[0].getAttribute(arguments[1]);', [this, name]);
    };
    Element.prototype.getProperty = function (name) {
        return this.session.execute('return arguments[0][arguments[1]];', [
            this,
            name
        ]);
    };
    Element.prototype.equals = function (other) {
        var _this = this;
        var elementId = other.elementId || other;
        return this._get('equals/$0', null, [
            elementId
        ]).catch(function (error) {
            if (error.name === 'UnknownCommand' ||
                (error.name === 'UnknownError' &&
                    error.message.indexOf('bug.For input string:') > -1)) {
                return _this.session.execute('return arguments[0] === arguments[1];', [_this, other]);
            }
            throw error;
        });
    };
    Element.prototype.isDisplayed = function () {
        var _this = this;
        return this._get('displayed').then(function (isDisplayed) {
            if (isDisplayed &&
                (_this.session.capabilities.brokenElementDisplayedOpacity ||
                    _this.session.capabilities.brokenElementDisplayedOffscreen)) {
                return _this.session.execute(function (element) {
                    var scrollX = document.documentElement.scrollLeft ||
                        document.body.scrollLeft;
                    var scrollY = document.documentElement.scrollTop ||
                        document.body.scrollTop;
                    do {
                        if (window.getComputedStyle(element).opacity === '0') {
                            return false;
                        }
                        var bbox = element.getBoundingClientRect();
                        if (bbox.right + scrollX <= 0 ||
                            bbox.bottom + scrollY <= 0) {
                            return false;
                        }
                    } while ((element = element.parentNode) &&
                        element.nodeType === 1);
                    return true;
                }, [_this]);
            }
            return isDisplayed;
        });
    };
    Element.prototype.getPosition = function () {
        if (this.session.capabilities.brokenElementPosition) {
            return this.session.execute(function (element) {
                var bbox = element.getBoundingClientRect();
                var scrollX = document.documentElement.scrollLeft ||
                    document.body.scrollLeft;
                var scrollY = document.documentElement.scrollTop ||
                    document.body.scrollTop;
                return { x: scrollX + bbox.left, y: scrollY + bbox.top };
            }, [this]);
        }
        return this._get('location').then(function (_a) {
            var x = _a.x, y = _a.y;
            return { x: x, y: y };
        });
    };
    Element.prototype.getSize = function () {
        var _this = this;
        var getUsingExecute = function () {
            return _this.session.execute(function (element) {
                var bbox = element.getBoundingClientRect();
                return {
                    width: bbox.right - bbox.left,
                    height: bbox.bottom - bbox.top
                };
            }, [_this]);
        };
        if (this.session.capabilities.brokenCssTransformedSize) {
            return getUsingExecute();
        }
        return this._get('size')
            .catch(function (error) {
            if (error.name === 'UnknownCommand') {
                return getUsingExecute();
            }
            throw error;
        })
            .then(function (_a) {
            var width = _a.width, height = _a.height;
            return { width: width, height: height };
        });
    };
    Element.prototype.getComputedStyle = function (propertyName) {
        var _this = this;
        var manualGetStyle = function () {
            return _this.session.execute(function (element, propertyName) {
                return window.getComputedStyle(element)[propertyName];
            }, [_this, propertyName]);
        };
        var promise;
        if (this.session.capabilities.brokenComputedStyles) {
            promise = manualGetStyle();
        }
        else {
            promise = this._get('css/$0', null, [
                propertyName
            ]).catch(function (error) {
                if (error.name === 'UnknownCommand') {
                    return manualGetStyle();
                }
                else if (error.name === 'UnknownError' &&
                    error.message.indexOf('failed to parse value') > -1) {
                    return '';
                }
                throw error;
            });
        }
        return promise.then(function (value) {
            if (value) {
                value = value.replace(/(.*\b)rgb\((\d+,\s*\d+,\s*\d+)\)(.*)/g, function (_, prefix, rgb, suffix) {
                    return prefix + 'rgba(' + rgb + ', 1)' + suffix;
                });
            }
            return value != null ? value : '';
        });
    };
    Element.prototype.findDisplayed = function (using, value) {
        return findDisplayed_1.default(this.session, this, using, value);
    };
    Element.prototype.waitForDeleted = function (strategy, value) {
        return waitForDeleted_1.default(this.session, this, strategy, value);
    };
    return Element;
}(Locator_1.default));
exports.default = Element;
function noop() {
}
//# sourceMappingURL=Element.js.map