{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../src/lib/util.ts"],"names":[],"mappings":";;AAAA,8CAAyC;AACzC,wCAAwC;AAOxC,eAAsB,EAAU;IAC/B,IAAI,KAAmB,CAAC;IACxB,MAAM,CAAC,IAAI,cAAI,CACd,UAAS,OAAO;QACf,KAAK,GAAG,UAAU,CAAC;YAClB,OAAO,EAAE,CAAC;QACX,CAAC,EAAE,EAAE,CAAC,CAAC;IACR,CAAC,EACD,cAAM,OAAA,YAAY,CAAC,KAAK,CAAC,EAAnB,CAAmB,CACzB,CAAC;AACH,CAAC;AAVD,sBAUC;AAMD,oBACC,EAAY,EACZ,UAA+D;IAE/D,MAAM,CAAC,YAAK,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;AAC9B,CAAC;AALD,gCAKC;AAMD,yBAAgC,EAAqB;IACpD,EAAE,CAAC,CAAC,OAAO,EAAE,KAAK,UAAU,CAAC,CAAC,CAAC;QAM9B,EAAE,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,qBAAqB,EAAE,EAAE,CAAC,CAAC;QACtD,EAAE,GAAG,UAAU,GAAG,EAAE,GAAG,2BAA2B,CAAC;IACpD,CAAC;IAED,MAAM,CAAC,EAAE,CAAC;AACX,CAAC;AAZD,0CAYC;AAOD,mBAA0B,KAAa;IACtC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;AACrC,CAAC;AAFD,8BAEC","sourcesContent":["import Task from '@dojo/core/async/Task';\nimport { mixin } from '@dojo/core/lang';\n\n/**\n * Creates a promise that resolves itself after `ms` milliseconds.\n *\n * @param ms Time until resolution in milliseconds.\n */\nexport function sleep(ms: number): Task<void> {\n\tlet timer: NodeJS.Timer;\n\treturn new Task<void>(\n\t\tfunction(resolve) {\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\tresolve();\n\t\t\t}, ms);\n\t\t},\n\t\t() => clearTimeout(timer)\n\t);\n}\n\n/**\n * Annotates the method with additional properties that provide guidance to\n * [[Command]] about how the method interacts with stored context elements.\n */\nexport function forCommand(\n\tfn: Function,\n\tproperties: { usesElement?: boolean; createsContext?: boolean }\n): Function {\n\treturn mixin(fn, properties);\n}\n\n/**\n * Converts a function to a string representation suitable for use with the\n * `execute` API endpoint.\n */\nexport function toExecuteString(fn: Function | string): string {\n\tif (typeof fn === 'function') {\n\t\t// If someone runs code through Istanbul in the test runner, inline\n\t\t// functions that are supposed to execute on the client will contain\n\t\t// code coverage variables that will cause script execution failure.\n\t\t// These statements are very simple and are generated in a consistent\n\t\t// manner, so we can get rid of them easily with a regular expression\n\t\tfn = fn.toString().replace(/\\b__cov_[^,;]+[,;]/g, '');\n\t\tfn = 'return (' + fn + ').apply(this, arguments);';\n\t}\n\n\treturn fn;\n}\n\n/**\n * Removes the first line of a stack trace, which in V8 is the string\n * representation of the object holding the stack trace (which is garbage for\n * captured stack traces).\n */\nexport function trimStack(stack: string): string {\n\treturn stack.replace(/^[^\\n]+/, '');\n}\n"]}