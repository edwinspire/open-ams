{"version":3,"file":"Tunnel.js","sourceRoot":"","sources":["../../src/Tunnel.ts"],"names":[],"mappings":"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","sourcesContent":["import Evented from '@dojo/core/Evented';\nimport { EventObject, Handle } from '@dojo/core/interfaces';\nimport { createCompositeHandle, mixin } from '@dojo/core/lang';\nimport Task, { State } from '@dojo/core/async/Task';\nimport sendRequest from '@dojo/core/request';\nimport { Response } from '@dojo/core/request/interfaces';\nimport { NodeRequestOptions } from '@dojo/core/request/providers/node';\nimport { spawn, ChildProcess } from 'child_process';\nimport { join } from 'path';\nimport { format as formatUrl, Url } from 'url';\nimport { fileExists, kill, on } from './util';\nimport { JobState } from './interfaces';\nimport * as decompress from 'decompress';\n\n/**\n * A Tunnel is a mechanism for connecting to a WebDriver service provider that\n * securely exposes local services for testing within the service provider’s\n * network.\n */\nexport default class Tunnel extends Evented<TunnelEvents, string>\n\timplements TunnelProperties, Url {\n\t/**\n\t * The URL of a service that provides a list of environments supported by\n\t * the tunnel.\n\t */\n\tenvironmentUrl: string | undefined;\n\n\t/**\n\t * The tunnel access key. This will be initialized with a tunnel-specific\n\t * environment variable if not specified.\n\t */\n\taccessKey: string | undefined;\n\n\t/**\n\t * The tunnel username. This will be initialized with a tunnel-specific\n\t * environment variable if not specified.\n\t */\n\tusername: string | undefined;\n\n\t/**\n\t * The architecture the tunnel will run against. This information is\n\t * automatically retrieved for the current system at runtime.\n\t */\n\tarchitecture!: string;\n\n\t/**\n\t * An HTTP authorization string to use when initiating connections to the\n\t * tunnel. This value of this property is defined by Tunnel subclasses.\n\t */\n\tauth: string | undefined;\n\n\t/**\n\t * The directory where the tunnel software will be extracted. If the\n\t * directory does not exist, it will be created. This value is set by the\n\t * tunnel subclasses.\n\t */\n\tdirectory!: string;\n\n\t/**\n\t * The executable to spawn in order to create a tunnel. This value is set\n\t * by the tunnel subclasses.\n\t */\n\texecutable!: string;\n\n\t/**\n\t * The host on which a WebDriver client can access the service provided by\n\t * the tunnel. This may or may not be the host where the tunnel application\n\t * is running.\n\t */\n\thostname!: string;\n\n\t/**\n\t * The path that a WebDriver client should use to access the service\n\t * provided by the tunnel.\n\t */\n\tpathname!: string;\n\n\t/**\n\t * The operating system the tunnel will run on. This information is\n\t * automatically retrieved for the current system at runtime.\n\t */\n\tplatform!: string;\n\n\t/**\n\t * The local port where the WebDriver server should be exposed by the\n\t * tunnel. This is typed as a string for Url compatibility, but should be a\n\t * number.\n\t */\n\tport!: string;\n\n\t/**\n\t * The protocol (e.g., 'http') that a WebDriver client should use to access\n\t * the service provided by the tunnel.\n\t */\n\tprotocol!: string;\n\n\t/**\n\t * The URL of a proxy server for the tunnel to go through. Only the\n\t * hostname, port, and auth are used.\n\t */\n\tproxy: string | undefined;\n\n\t/** A unique identifier for the newly created tunnel. */\n\ttunnelId: string | undefined;\n\n\t/** The URL where the tunnel software can be downloaded. */\n\turl!: string;\n\n\t/** Whether or not to tell the tunnel to provide verbose logging output. */\n\tverbose!: boolean;\n\n\tprotected _startTask: Task<any> | undefined;\n\tprotected _stopTask: Promise<number> | undefined;\n\tprotected _handle: Handle | undefined;\n\tprotected _process: ChildProcess | undefined;\n\tprotected _state!: 'stopped' | 'starting' | 'running' | 'stopping';\n\n\tconstructor(options?: TunnelOptions) {\n\t\tsuper();\n\t\tmixin(\n\t\t\tthis,\n\t\t\t{\n\t\t\t\tarchitecture: process.arch,\n\t\t\t\thostname: 'localhost',\n\t\t\t\tpathname: '/wd/hub/',\n\t\t\t\tplatform: process.platform,\n\t\t\t\tport: 4444,\n\t\t\t\tprotocol: 'http',\n\t\t\t\tverbose: false,\n\t\t\t\tstate: 'stopped'\n\t\t\t},\n\t\t\toptions || {}\n\t\t);\n\t}\n\n\t/**\n\t * The URL that a WebDriver client should used to interact with this\n\t * service.\n\t */\n\tget clientUrl(): string {\n\t\treturn formatUrl(this);\n\t}\n\n\t/**\n\t * A map of additional capabilities that need to be sent to the provider\n\t * when a new session is being created.\n\t */\n\tget extraCapabilities(): Object {\n\t\treturn {};\n\t}\n\n\t/**\n\t * Whether or not the tunnel software has already been downloaded.\n\t */\n\tget isDownloaded(): boolean {\n\t\treturn fileExists(this.executable);\n\t}\n\n\t/**\n\t * Whether or not the tunnel is currently running.\n\t */\n\tget isRunning(): boolean {\n\t\treturn this._state === 'running';\n\t}\n\n\t/**\n\t * Whether or not the tunnel is currently starting up.\n\t */\n\tget isStarting(): boolean {\n\t\treturn this._state === 'starting';\n\t}\n\n\t/**\n\t * Whether or not the tunnel is currently stopping.\n\t */\n\tget isStopping(): boolean {\n\t\treturn this._state === 'stopping';\n\t}\n\n\t/**\n\t * Downloads and extracts the tunnel software if it is not already\n\t * downloaded.\n\t *\n\t * This method can be extended by implementations to perform any necessary\n\t * post-processing, such as setting appropriate file permissions on the\n\t * downloaded executable.\n\t *\n\t * @param forceDownload Force downloading the software even if it already\n\t * has been downloaded.\n\t * @returns A promise that resolves once the download and extraction process\n\t * has completed.\n\t */\n\tdownload(forceDownload = false): Task<void> {\n\t\tif (!forceDownload && this.isDownloaded) {\n\t\t\treturn Task.resolve();\n\t\t}\n\t\treturn this._downloadFile(this.url, this.proxy);\n\t}\n\n\tprotected _downloadFile(\n\t\turl: string | undefined,\n\t\tproxy: string | undefined,\n\t\toptions?: DownloadOptions\n\t): Task<void> {\n\t\tlet request: Task<Response>;\n\n\t\tif (!url) {\n\t\t\treturn Task.reject(new Error('URL is empty'));\n\t\t}\n\n\t\treturn new Task<void>(\n\t\t\t(resolve, reject) => {\n\t\t\t\trequest = sendRequest(url, <NodeRequestOptions>{ proxy });\n\t\t\t\trequest\n\t\t\t\t\t.then(response => {\n\t\t\t\t\t\tconst total = Number(\n\t\t\t\t\t\t\tresponse.headers.get('content-length')\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tresponse.download.subscribe({\n\t\t\t\t\t\t\tnext: received => {\n\t\t\t\t\t\t\t\tthis.emit({\n\t\t\t\t\t\t\t\t\ttype: 'downloadprogress',\n\t\t\t\t\t\t\t\t\ttarget: this,\n\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\ttotal,\n\t\t\t\t\t\t\t\t\treceived\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (response.status >= 400) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Download server returned status code ${\n\t\t\t\t\t\t\t\t\tresponse.status\n\t\t\t\t\t\t\t\t} for ${url}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresponse.arrayBuffer().then(data => {\n\t\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t\tthis._postDownloadFile(\n\t\t\t\t\t\t\t\t\t\tBuffer.from(data),\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t() => {\n\t\t\t\trequest && request.cancel();\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Called with the response after a file download has completed\n\t */\n\tprotected _postDownloadFile(\n\t\tdata: Buffer,\n\t\toptions?: DownloadOptions\n\t): Promise<void> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tlet directory = this.directory;\n\t\t\tif (options && options.directory) {\n\t\t\t\tdirectory = join(directory, options.directory);\n\t\t\t}\n\t\t\tdecompress(data, directory)\n\t\t\t\t.then(() => resolve())\n\t\t\t\t.catch(reject);\n\t\t});\n\t}\n\n\t/**\n\t * Creates the list of command-line arguments to be passed to the spawned\n\t * tunnel. Implementations should override this method to provide the\n\t * appropriate command-line arguments.\n\t *\n\t * Arguments passed to [[Tunnel._makeChild]] will be passed as-is to this\n\t * method.\n\t *\n\t * @returns A list of command-line arguments.\n\t */\n\tprotected _makeArgs(..._values: string[]): string[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * Creates a newly spawned child process for the tunnel software.\n\t * Implementations should call this method to create the tunnel process.\n\t *\n\t * Arguments passed to this method will be passed as-is to\n\t * [[Tunnel._makeArgs]] and [[Tunnel._makeOptions]].\n\t *\n\t * @returns An object containing a newly spawned Process and a Deferred that\n\t * will be resolved once the tunnel has started successfully.\n\t */\n\tprotected _makeChild(\n\t\texecutor: ChildExecutor,\n\t\t...values: string[]\n\t): Task<any> {\n\t\tconst command = this.executable;\n\t\tconst args = this._makeArgs(...values);\n\t\tconst options = this._makeOptions(...values);\n\t\tconst child = spawn(command, args, options);\n\n\t\tchild.stdout.setEncoding('utf8');\n\t\tchild.stderr.setEncoding('utf8');\n\n\t\tlet handle: Handle;\n\t\tlet canceled = false;\n\t\tconst task = new Task(\n\t\t\t(resolve, reject) => {\n\t\t\t\tlet errorMessage = '';\n\t\t\t\tlet exitCode: number | undefined;\n\t\t\t\tlet stderrClosed = false;\n\t\t\t\tlet exitted = false;\n\n\t\t\t\tfunction handleChildExit() {\n\t\t\t\t\tif (task.state === State.Pending) {\n\t\t\t\t\t\treject(\n\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t`Tunnel failed to start: ${errorMessage ||\n\t\t\t\t\t\t\t\t\t`Exit code: ${exitCode}`}`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thandle = createCompositeHandle(\n\t\t\t\t\ton(child, 'error', reject),\n\n\t\t\t\t\ton(child.stderr, 'data', (data: string) => {\n\t\t\t\t\t\terrorMessage += data;\n\t\t\t\t\t}),\n\n\t\t\t\t\ton(child, 'exit', () => {\n\t\t\t\t\t\texitted = true;\n\t\t\t\t\t\tif (stderrClosed) {\n\t\t\t\t\t\t\thandleChildExit();\n\t\t\t\t\t\t}\n\t\t\t\t\t}),\n\n\t\t\t\t\t// stderr might still have data in buffer at the time the\n\t\t\t\t\t// exit event is sent, so we have to store data from stderr\n\t\t\t\t\t// and the exit code and reject only once stderr closes\n\t\t\t\t\ton(child.stderr, 'close', () => {\n\t\t\t\t\t\tstderrClosed = true;\n\t\t\t\t\t\tif (exitted) {\n\t\t\t\t\t\t\thandleChildExit();\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t);\n\n\t\t\t\tconst result = executor(child, resolve, reject);\n\t\t\t\tif (result) {\n\t\t\t\t\thandle = createCompositeHandle(handle, result);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => {\n\t\t\t\tcanceled = true;\n\n\t\t\t\t// Make a best effort to kill the process, but don't throw\n\t\t\t\t// exceptions\n\t\t\t\ttry {\n\t\t\t\t\tkill(child.pid);\n\t\t\t\t} catch (error) {}\n\t\t\t}\n\t\t);\n\n\t\treturn task.finally(() => {\n\t\t\thandle.destroy();\n\t\t\tif (canceled) {\n\t\t\t\t// We only want this to run when cancelation has occurred\n\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\tchild.once('exit', () => {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Creates the set of options to use when spawning the tunnel process.\n\t * Implementations should override this method to provide the appropriate\n\t * options for the tunnel software.\n\t *\n\t * Arguments passed to [[Tunnel._makeChild]] will be passed as-is to this\n\t * method.\n\t *\n\t * @returns A set of options matching those provided to Node.js\n\t * `child_process.spawn`.\n\t */\n\tprotected _makeOptions(..._values: string[]) {\n\t\treturn { env: process.env };\n\t}\n\n\t/**\n\t * Sends information about a job to the tunnel provider.\n\t *\n\t * @param jobId The job to send data about. This is usually a session ID.\n\t * @param data Data to send to the tunnel provider about the job.\n\t * @returns A promise that resolves once the job state request is complete.\n\t */\n\tsendJobState(_jobId: string, _data: JobState): Task<void> {\n\t\treturn Task.reject(\n\t\t\tnew Error('Job state is not supported by this tunnel.')\n\t\t);\n\t}\n\n\t/**\n\t * Starts the tunnel, automatically downloading dependencies if necessary.\n\t *\n\t * @returns A promise that resolves once the tunnel has been established.\n\t */\n\tstart() {\n\t\tswitch (this._state) {\n\t\t\tcase 'stopping':\n\t\t\t\tthrow new Error('Previous tunnel is still terminating');\n\t\t\tcase 'running':\n\t\t\tcase 'starting':\n\t\t\t\treturn this._startTask!;\n\t\t}\n\n\t\tthis._state = 'starting';\n\n\t\tthis._startTask = this.download().then(() => {\n\t\t\treturn this._start(child => {\n\t\t\t\tthis._process = child;\n\t\t\t\tthis._handle = createCompositeHandle(\n\t\t\t\t\tthis._handle || { destroy: function() {} },\n\t\t\t\t\ton(child.stdout, 'data', proxyIOEvent(this, 'stdout')),\n\t\t\t\t\ton(child.stderr, 'data', proxyIOEvent(this, 'stderr')),\n\t\t\t\t\ton(child, 'exit', () => {\n\t\t\t\t\t\tthis._state = 'stopped';\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\n\t\tthis._startTask\n\t\t\t.then(() => {\n\t\t\t\tthis._startTask = undefined;\n\t\t\t\tthis._state = 'running';\n\t\t\t\tthis.emit({\n\t\t\t\t\ttype: 'status',\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tstatus: 'Ready'\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tthis._startTask = undefined;\n\t\t\t\tthis._state = 'stopped';\n\t\t\t\tthis.emit({\n\t\t\t\t\ttype: 'status',\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tstatus:\n\t\t\t\t\t\terror.name === 'CancelError'\n\t\t\t\t\t\t\t? 'Start cancelled'\n\t\t\t\t\t\t\t: 'Failed to start tunnel'\n\t\t\t\t});\n\t\t\t});\n\n\t\treturn this._startTask!;\n\t}\n\n\t/**\n\t * This method provides the implementation that actually starts the tunnel\n\t * and any other logic for emitting events on the Tunnel based on data\n\t * passed by the tunnel software.\n\t *\n\t * The default implementation that assumes the tunnel is ready for use once\n\t * the child process has written to `stdout` or `stderr`. This method should\n\t * be reimplemented by other tunnel launchers to implement correct launch\n\t * detection logic.\n\t *\n\t * @returns An object containing a reference to the child process, and a\n\t * Deferred that is resolved once the tunnel is ready for use. Normally this\n\t * will be the object returned from a call to [[Tunnel._makeChild]].\n\t */\n\tprotected _start(executor: ChildExecutor) {\n\t\treturn this._makeChild((child, resolve, reject) => {\n\t\t\tconst handle = createCompositeHandle(\n\t\t\t\ton(child.stdout, 'data', resolve),\n\t\t\t\ton(child.stderr, 'data', resolve),\n\t\t\t\ton(child, 'error', (error: Error) => {\n\t\t\t\t\treject(error);\n\t\t\t\t})\n\t\t\t);\n\n\t\t\ttry {\n\t\t\t\texecutor(child, resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\n\t\t\treturn handle;\n\t\t});\n\t}\n\n\t/**\n\t * Stops the tunnel.\n\t *\n\t * @returns A promise that resolves to the exit code for the tunnel once it\n\t * has been terminated.\n\t */\n\tstop(): Promise<number> {\n\t\tswitch (this._state) {\n\t\t\tcase 'starting':\n\t\t\t\tthis._startTask!.cancel();\n\t\t\t\treturn this._startTask!.finally(() => null);\n\t\t\tcase 'stopping':\n\t\t\t\treturn this._stopTask!;\n\t\t}\n\n\t\tthis._state = 'stopping';\n\n\t\tthis.emit({\n\t\t\ttype: 'status',\n\t\t\ttarget: this,\n\t\t\tstatus: 'Stopping'\n\t\t});\n\n\t\tthis._stopTask = this._stop()\n\t\t\t.then(returnValue => {\n\t\t\t\tif (this._handle) {\n\t\t\t\t\tthis._handle.destroy();\n\t\t\t\t}\n\t\t\t\tthis._process = this._handle = undefined;\n\t\t\t\tthis._state = 'stopped';\n\t\t\t\tthis.emit({\n\t\t\t\t\ttype: 'status',\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tstatus: 'Stopped'\n\t\t\t\t});\n\t\t\t\treturn returnValue;\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tthis._state = 'running';\n\t\t\t\tthrow error;\n\t\t\t});\n\n\t\treturn this._stopTask;\n\t}\n\n\t/**\n\t * This method provides the implementation that actually stops the tunnel.\n\t *\n\t * The default implementation that assumes the tunnel has been closed once\n\t * the child process has exited. This method should be reimplemented by\n\t * other tunnel launchers to implement correct shutdown logic, if necessary.\n\t *\n\t * @returns A promise that resolves once the tunnel has shut down.\n\t */\n\tprotected _stop(): Promise<number> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst childProcess = this._process;\n\t\t\tif (!childProcess) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchildProcess.once('exit', code => {\n\t\t\t\tresolve(code);\n\t\t\t});\n\n\t\t\ttry {\n\t\t\t\tkill(childProcess.pid);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get a list of environments available on the service.\n\t *\n\t * This method should be overridden and use a specific implementation that\n\t * returns normalized environments from the service. E.g.\n\t *\n\t * ```js\n\t * {\n\t *     browserName: 'firefox',\n\t *     version: '12',\n\t *     platform: 'windows',\n\t *     descriptor: { <original returned environment> }\n\t * }\n\t * ```\n\t *\n\t * @returns An object containing the response and helper functions\n\t */\n\tgetEnvironments(): Task<NormalizedEnvironment[]> {\n\t\tif (!this.environmentUrl) {\n\t\t\treturn Task.resolve([]);\n\t\t}\n\n\t\treturn sendRequest(this.environmentUrl, <NodeRequestOptions>{\n\t\t\tpassword: this.accessKey,\n\t\t\tuser: this.username,\n\t\t\tproxy: this.proxy\n\t\t}).then(response => {\n\t\t\tif (response.status >= 200 && response.status < 400) {\n\t\t\t\treturn response.json<any[]>().then(data => {\n\t\t\t\t\treturn data.reduce(\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tenvironments: NormalizedEnvironment[],\n\t\t\t\t\t\t\tenvironment: any\n\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\treturn environments.concat(\n\t\t\t\t\t\t\t\tthis._normalizeEnvironment(environment)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\t[]\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (response.status === 401) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Missing or invalid username and access key'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Server replied with a status of ${response.status}`\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Normalizes a specific Tunnel environment descriptor to a general form. To\n\t * be overriden by a child implementation.\n\t *\n\t * @param environment an environment descriptor specific to the Tunnel\n\t * @returns a normalized environment\n\t */\n\tprotected _normalizeEnvironment(\n\t\tenvironment: Object\n\t): NormalizedEnvironment {\n\t\treturn <any>environment;\n\t}\n}\n\nexport interface TunnelEventObject<T> extends EventObject<string> {\n\treadonly target: T;\n}\n\nexport interface TunnelEvents {\n\tstdout: IOEvent;\n\tstderr: IOEvent;\n\tstatus: StatusEvent;\n\tdownloadprogress: DownloadProgressEvent;\n\t[index: string]: any;\n}\n\n/**\n * A chunk of raw string data output by the tunnel software to stdout or stderr.\n */\n// tslint:disable-next-line:interface-name\nexport interface IOEvent extends TunnelEventObject<Tunnel> {\n\treadonly type: 'stdout' | 'stderr';\n\treadonly data: string;\n}\n\n/**\n * An event containing information about the status of the tunnel setup process\n * that is suitable for presentation to end-users.\n */\nexport interface StatusEvent extends TunnelEventObject<Tunnel> {\n\treadonly type: 'status';\n\treadonly status: string;\n}\n\n/**\n * An event indicating that part of a tunnel binary has been downloaded from the\n * server.\n */\nexport interface DownloadProgressEvent extends TunnelEventObject<Tunnel> {\n\t/** The event type */\n\treadonly type: 'downloadprogress';\n\t/** The URL being downloaded from */\n\treadonly url: string;\n\t/** The total number of bytes being downloaded */\n\treadonly total: number;\n\t/** The number of bytes received so far */\n\treadonly received: number;\n}\n\n/**\n * A handle to a child process, along with resolve and reject callbacks that can\n * be used to settle an associated Promise.\n */\nexport interface ChildExecutor {\n\t(\n\t\tchild: ChildProcess,\n\t\tresolve: () => void,\n\t\treject: (reason?: any) => void\n\t): Handle | void;\n}\n\n/** Options for file downloads */\nexport interface DownloadOptions {\n\tdirectory: string | undefined;\n\tproxy: string | undefined;\n\turl: string;\n}\n\n/**\n * A normalized environment descriptor.\n *\n * A NormalizedEnvironment contains a mix of W3C WebDriver and JSONWireProtocol\n * capabilities, as well as a set of standardized capabilities that can be used\n * to specify the given environment in an Intern `environments` descriptor.\n */\nexport interface NormalizedEnvironment {\n\tbrowserName: string;\n\tbrowserVersion?: string;\n\tdescriptor: Object;\n\tplatform: string;\n\tplatformName?: string;\n\tplatformVersion?: string;\n\tversion: string;\n\n\tintern: {\n\t\tplatform: string;\n\t\tbrowserName: string;\n\t\tversion: string;\n\t};\n}\n\n/** Properties of a tunnel */\nexport interface TunnelProperties extends DownloadOptions {\n\tarchitecture: string;\n\tauth: string | undefined;\n\taccessKey: string | undefined;\n\texecutable: string | undefined;\n\thostname: string;\n\tpathname: string;\n\tplatform: string;\n\n\t/**\n\t * Port should be a number, but the property is typed as a string for\n\t * compatibility with Url\n\t */\n\tport: string;\n\n\tprotocol: string;\n\ttunnelId: string | undefined;\n\tusername: string | undefined;\n\tverbose: boolean;\n}\n\n/** Options used to configure a tunnel */\nexport type TunnelOptions = Partial<TunnelProperties>;\n\nfunction proxyIOEvent(target: Tunnel, type: 'stdout' | 'stderr') {\n\treturn function(data: any) {\n\t\ttarget.emit({\n\t\t\ttype,\n\t\t\ttarget,\n\t\t\tdata: String(data)\n\t\t});\n\t};\n}\n\ndelete Tunnel.prototype.on;\n"]}