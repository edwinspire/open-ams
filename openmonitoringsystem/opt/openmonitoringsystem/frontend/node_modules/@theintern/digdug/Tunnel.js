"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Evented_1 = require("@dojo/core/Evented");
var lang_1 = require("@dojo/core/lang");
var Task_1 = require("@dojo/core/async/Task");
var request_1 = require("@dojo/core/request");
var child_process_1 = require("child_process");
var url_1 = require("url");
var util_1 = require("./util");
var decompress = require("decompress");
var Tunnel = (function (_super) {
    tslib_1.__extends(Tunnel, _super);
    function Tunnel(options) {
        var _this = _super.call(this) || this;
        _this._state = 'stopped';
        lang_1.mixin(_this, {
            architecture: process.arch,
            hostname: 'localhost',
            pathname: '/wd/hub/',
            platform: process.platform,
            port: 4444,
            protocol: 'http',
            verbose: false
        }, options || {});
        return _this;
    }
    Object.defineProperty(Tunnel.prototype, "clientUrl", {
        get: function () {
            return url_1.format(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "extraCapabilities", {
        get: function () {
            return {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "isDownloaded", {
        get: function () {
            return util_1.fileExists(this.executable);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "isRunning", {
        get: function () {
            return this._state === 'running';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "isStarting", {
        get: function () {
            return this._state === 'starting';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tunnel.prototype, "isStopping", {
        get: function () {
            return this._state === 'stopping';
        },
        enumerable: true,
        configurable: true
    });
    Tunnel.prototype.download = function (forceDownload) {
        if (forceDownload === void 0) { forceDownload = false; }
        if (!forceDownload && this.isDownloaded) {
            return Task_1.default.resolve();
        }
        return this._downloadFile(this.url, this.proxy);
    };
    Tunnel.prototype._downloadFile = function (url, proxy, options) {
        var _this = this;
        var request;
        if (!url) {
            return Task_1.default.reject(new Error('URL is empty'));
        }
        return new Task_1.default(function (resolve, reject) {
            request = request_1.default(url, { proxy: proxy });
            request
                .then(function (response) {
                var total = Number(response.headers.get('content-length'));
                response.download.subscribe({
                    next: function (received) {
                        _this.emit({
                            type: 'downloadprogress',
                            target: _this,
                            url: url,
                            total: total,
                            received: received
                        });
                    }
                });
                if (response.status >= 400) {
                    throw new Error("Download server returned status code " + response.status + " for " + url);
                }
                else {
                    response.arrayBuffer().then(function (data) {
                        resolve(_this._postDownloadFile(Buffer.from(data), options));
                    });
                }
            })
                .catch(function (error) {
                reject(error);
            });
        }, function () {
            request && request.cancel();
        });
    };
    Tunnel.prototype._postDownloadFile = function (data, _options) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            decompress(data, _this.directory)
                .then(function () { return resolve(); })
                .catch(reject);
        });
    };
    Tunnel.prototype._makeArgs = function () {
        var _values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _values[_i] = arguments[_i];
        }
        return [];
    };
    Tunnel.prototype._makeChild = function (executor) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        var command = this.executable;
        var args = this._makeArgs.apply(this, values);
        var options = this._makeOptions.apply(this, values);
        var child = child_process_1.spawn(command, args, options);
        child.stdout.setEncoding('utf8');
        child.stderr.setEncoding('utf8');
        var handle;
        var canceled = false;
        var task = new Task_1.default(function (resolve, reject) {
            var errorMessage = '';
            var exitCode;
            var stderrClosed = false;
            function handleChildExit() {
                if (task.state === 1) {
                    reject(new Error("Tunnel failed to start: " + (errorMessage ||
                        "Exit code: " + exitCode)));
                }
            }
            handle = lang_1.createCompositeHandle(util_1.on(child, 'error', reject), util_1.on(child.stderr, 'data', function (data) {
                errorMessage += data;
            }), util_1.on(child, 'exit', function (code) {
                exitCode = code;
                if (stderrClosed) {
                    handleChildExit();
                }
            }), util_1.on(child.stderr, 'close', function () {
                stderrClosed = true;
                if (exitCode !== null) {
                    handleChildExit();
                }
            }));
            var result = executor(child, resolve, reject);
            if (result) {
                handle = lang_1.createCompositeHandle(handle, result);
            }
        }, function () {
            canceled = true;
            child.kill('SIGINT');
        });
        return task.finally(function () {
            handle.destroy();
            if (canceled) {
                return new Promise(function (resolve) {
                    child.once('exit', function () {
                        resolve();
                    });
                });
            }
        });
    };
    Tunnel.prototype._makeOptions = function () {
        var _values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _values[_i] = arguments[_i];
        }
        return { env: process.env };
    };
    Tunnel.prototype.sendJobState = function (_jobId, _data) {
        return Task_1.default.reject(new Error('Job state is not supported by this tunnel.'));
    };
    Tunnel.prototype.start = function () {
        var _this = this;
        switch (this._state) {
            case 'stopping':
                throw new Error('Previous tunnel is still terminating');
            case 'running':
            case 'starting':
                return this._startTask;
        }
        this._state = 'starting';
        this._startTask = this.download().then(function () {
            return _this._start(function (child) {
                _this._process = child;
                _this._handle = lang_1.createCompositeHandle(_this._handle || { destroy: function () { } }, util_1.on(child.stdout, 'data', proxyIOEvent(_this, 'stdout')), util_1.on(child.stderr, 'data', proxyIOEvent(_this, 'stderr')), util_1.on(child, 'exit', function () {
                    _this._state = 'stopped';
                }));
            });
        });
        this._startTask
            .then(function () {
            _this._startTask = undefined;
            _this._state = 'running';
            _this.emit({
                type: 'status',
                target: _this,
                status: 'Ready'
            });
        })
            .catch(function (error) {
            _this._startTask = undefined;
            _this._state = 'stopped';
            _this.emit({
                type: 'status',
                target: _this,
                status: error.name === 'CancelError'
                    ? 'Start cancelled'
                    : 'Failed to start tunnel'
            });
        });
        return this._startTask;
    };
    Tunnel.prototype._start = function (executor) {
        return this._makeChild(function (child, resolve, reject) {
            var handle = lang_1.createCompositeHandle(util_1.on(child.stdout, 'data', resolve), util_1.on(child.stderr, 'data', resolve), util_1.on(child, 'error', function (error) {
                reject(error);
            }));
            executor(child, resolve, reject);
            return handle;
        });
    };
    Tunnel.prototype.stop = function () {
        var _this = this;
        switch (this._state) {
            case 'starting':
                this._startTask.cancel();
                return this._startTask.finally(function () { return null; });
            case 'stopping':
                return this._stopTask;
        }
        this._state = 'stopping';
        this.emit({
            type: 'status',
            target: this,
            status: 'Stopping'
        });
        this._stopTask = this._stop()
            .then(function (returnValue) {
            if (_this._handle) {
                _this._handle.destroy();
            }
            _this._process = _this._handle = undefined;
            _this._state = 'stopped';
            _this.emit({
                type: 'status',
                target: _this,
                status: 'Stopped'
            });
            return returnValue;
        })
            .catch(function (error) {
            _this._state = 'running';
            throw error;
        });
        return this._stopTask;
    };
    Tunnel.prototype._stop = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var childProcess = _this._process;
            if (!childProcess) {
                resolve();
                return;
            }
            childProcess.once('exit', function (code) {
                resolve(code);
            });
            childProcess.kill('SIGINT');
        });
    };
    Tunnel.prototype.getEnvironments = function () {
        var _this = this;
        if (!this.environmentUrl) {
            return Task_1.default.resolve([]);
        }
        return request_1.default(this.environmentUrl, {
            password: this.accessKey,
            user: this.username,
            proxy: this.proxy
        }).then(function (response) {
            if (response.status >= 200 && response.status < 400) {
                return response.json().then(function (data) {
                    return data.reduce(function (environments, environment) {
                        return environments.concat(_this._normalizeEnvironment(environment));
                    }, []);
                });
            }
            else {
                if (response.status === 401) {
                    throw new Error('Missing or invalid username and access key');
                }
                throw new Error("Server replied with a status of " + response.status);
            }
        });
    };
    Tunnel.prototype._normalizeEnvironment = function (environment) {
        return environment;
    };
    return Tunnel;
}(Evented_1.default));
exports.default = Tunnel;
function proxyIOEvent(target, type) {
    return function (data) {
        target.emit({
            type: type,
            target: target,
            data: String(data)
        });
    };
}
delete Tunnel.prototype.on;
//# sourceMappingURL=Tunnel.js.map