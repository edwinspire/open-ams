"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Tunnel_1 = require("./Tunnel");
var util_1 = require("util");
var path_1 = require("path");
var Task_1 = require("@dojo/core/async/Task");
var util_2 = require("./util");
var lang_1 = require("@dojo/core/lang");
var semver_1 = require("semver");
var SeleniumVersion = '3.5.2';
var ChromeVersion = '2.33';
var FirefoxVersion = '0.18.0';
var IEVersion = '3.5.1';
var SeleniumTunnel = (function (_super) {
    tslib_1.__extends(SeleniumTunnel, _super);
    function SeleniumTunnel(options) {
        return _super.call(this, lang_1.mixin({
            seleniumArgs: null,
            drivers: ['chrome'],
            baseUrl: 'https://selenium-release.storage.googleapis.com',
            version: SeleniumVersion,
            seleniumTimeout: 5000
        }, options || {})) || this;
    }
    Object.defineProperty(SeleniumTunnel.prototype, "artifact", {
        get: function () {
            return "selenium-server-standalone-" + this.version + ".jar";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeleniumTunnel.prototype, "directory", {
        get: function () {
            return path_1.join(__dirname, 'selenium-standalone');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeleniumTunnel.prototype, "executable", {
        get: function () {
            return 'java';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeleniumTunnel.prototype, "isDownloaded", {
        get: function () {
            var directory = this.directory;
            return (util_2.fileExists(path_1.join(directory, this.artifact)) &&
                this._getDriverConfigs().every(function (config) {
                    return util_2.fileExists(path_1.join(directory, config.executable));
                }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SeleniumTunnel.prototype, "url", {
        get: function () {
            var majorMinorVersion = this.version.slice(0, this.version.lastIndexOf('.'));
            return util_1.format('%s/%s/%s', this.baseUrl, majorMinorVersion, this.artifact);
        },
        enumerable: true,
        configurable: true
    });
    SeleniumTunnel.prototype.download = function (forceDownload) {
        var _this = this;
        if (forceDownload === void 0) { forceDownload = false; }
        if (!forceDownload && this.isDownloaded) {
            return Task_1.default.resolve();
        }
        var tasks;
        return new Task_1.default(function (resolve) {
            var configs = [
                {
                    url: _this.url,
                    executable: _this.artifact,
                    dontExtract: true
                }
            ].concat(_this._getDriverConfigs());
            tasks = configs.map(function (config) {
                var executable = config.executable;
                var dontExtract = Boolean(config.dontExtract);
                if (util_2.fileExists(path_1.join(_this.directory, executable))) {
                    return Task_1.default.resolve();
                }
                return _this._downloadFile(config.url, _this.proxy, { executable: executable, dontExtract: dontExtract });
            });
            resolve(Task_1.default.all(tasks).then(function () { }));
        }, function () {
            tasks &&
                tasks.forEach(function (task) {
                    task.cancel();
                });
        });
    };
    SeleniumTunnel.prototype.sendJobState = function () {
        return Task_1.default.resolve();
    };
    SeleniumTunnel.prototype._getDriverConfigs = function () {
        function getDriverConfig(name, options) {
            var Constructor = driverNameMap[name];
            if (!Constructor) {
                throw new Error('Invalid driver name "' + name + '"');
            }
            return new Constructor(options);
        }
        return this.drivers.map(function (data) {
            if (typeof data === 'string') {
                return getDriverConfig(data);
            }
            if (typeof data === 'object' && data.name) {
                return getDriverConfig(data.name, data);
            }
            return data;
        });
    };
    SeleniumTunnel.prototype._makeArgs = function () {
        var directory = this.directory;
        var driverConfigs = this._getDriverConfigs();
        var args = [];
        driverConfigs.reduce(function (args, config) {
            var file = path_1.join(directory, config.executable);
            args.push('-D' + config.seleniumProperty + '=' + file);
            return args;
        }, args);
        if (this.seleniumArgs) {
            args.push.apply(args, this.seleniumArgs);
        }
        args.push('-jar', path_1.join(this.directory, this.artifact), '-port', this.port);
        if (this.verbose) {
            args.push('-debug');
            if (semver_1.satisfies(this.version, '>=3.1.0 <3.5.0')) {
                args.push('true');
            }
            console.log('Starting with arguments: ', args.join(' '));
        }
        return args;
    };
    SeleniumTunnel.prototype._postDownloadFile = function (data, options) {
        var executable = options.executable;
        if (options.dontExtract) {
            return util_2.writeFile(data, path_1.join(this.directory, executable));
        }
        return _super.prototype._postDownloadFile.call(this, data, options);
    };
    SeleniumTunnel.prototype._start = function (executor) {
        var _this = this;
        var handle;
        var task = this._makeChild(function (child, resolve, reject) {
            handle = util_2.on(child.stderr, 'data', function (data) {
                data = String(data);
                if (data.indexOf('Selenium Server is up and running') > -1) {
                    resolve();
                }
                else if (data.indexOf('Address already in use') !== -1) {
                    reject(new Error('Address is already in use'));
                    child.kill('SIGINT');
                }
            });
            if (_this.verbose) {
                util_2.on(child.stderr, 'data', function (data) {
                    process.stderr.write(data);
                });
            }
            executor(child, resolve, reject);
        });
        task.then(function () { return handle.destroy(); }, function () { return handle.destroy(); });
        return task;
    };
    return SeleniumTunnel;
}(Tunnel_1.default));
exports.default = SeleniumTunnel;
var Config = (function () {
    function Config(config) {
        lang_1.mixin(this, config);
    }
    return Config;
}());
var ChromeConfig = (function (_super) {
    tslib_1.__extends(ChromeConfig, _super);
    function ChromeConfig(options) {
        return _super.call(this, lang_1.mixin({
            arch: process.arch,
            baseUrl: 'https://chromedriver.storage.googleapis.com',
            platform: process.platform,
            version: ChromeVersion
        }, options)) || this;
    }
    Object.defineProperty(ChromeConfig.prototype, "artifact", {
        get: function () {
            var platform = this.platform;
            if (platform === 'linux') {
                platform = 'linux' + (this.arch === 'x64' ? '64' : '32');
            }
            else if (platform === 'darwin') {
                var parts_1 = String(this.version)
                    .split('.')
                    .map(Number);
                var isGreater = [2, 22].some(function (part, i) {
                    return parts_1[i] > part;
                });
                platform = isGreater ? 'mac64' : 'mac32';
            }
            return util_1.format('chromedriver_%s.zip', platform);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChromeConfig.prototype, "url", {
        get: function () {
            return util_1.format('%s/%s/%s', this.baseUrl, this.version, this.artifact);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChromeConfig.prototype, "executable", {
        get: function () {
            return this.platform === 'win32' ? 'chromedriver.exe' : 'chromedriver';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChromeConfig.prototype, "seleniumProperty", {
        get: function () {
            return 'webdriver.chrome.driver';
        },
        enumerable: true,
        configurable: true
    });
    return ChromeConfig;
}(Config));
var FirefoxConfig = (function (_super) {
    tslib_1.__extends(FirefoxConfig, _super);
    function FirefoxConfig(options) {
        return _super.call(this, lang_1.mixin({
            arch: process.arch,
            baseUrl: 'https://github.com/mozilla/geckodriver/releases/download',
            platform: process.platform,
            version: FirefoxVersion
        }, options)) || this;
    }
    Object.defineProperty(FirefoxConfig.prototype, "artifact", {
        get: function () {
            var platform = this.platform;
            if (platform === 'linux') {
                platform = 'linux' + (this.arch === 'x64' ? '64' : '32');
            }
            else if (platform === 'win32') {
                platform = 'win' + (this.arch === 'x64' ? '64' : '32');
            }
            else if (platform === 'darwin') {
                platform = 'macos';
            }
            var extension = /^win/.test(platform) ? '.zip' : '.tar.gz';
            return util_1.format('geckodriver-v%s-%s%s', this.version, platform, extension);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirefoxConfig.prototype, "url", {
        get: function () {
            return util_1.format('%s/v%s/%s', this.baseUrl, this.version, this.artifact);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirefoxConfig.prototype, "executable", {
        get: function () {
            return this.platform === 'win32' ? 'geckodriver.exe' : 'geckodriver';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirefoxConfig.prototype, "seleniumProperty", {
        get: function () {
            return 'webdriver.gecko.driver';
        },
        enumerable: true,
        configurable: true
    });
    return FirefoxConfig;
}(Config));
var IEConfig = (function (_super) {
    tslib_1.__extends(IEConfig, _super);
    function IEConfig(options) {
        return _super.call(this, lang_1.mixin({
            arch: process.arch,
            baseUrl: 'https://selenium-release.storage.googleapis.com',
            version: IEVersion
        }, options)) || this;
    }
    Object.defineProperty(IEConfig.prototype, "artifact", {
        get: function () {
            var architecture = this.arch === 'x64' ? 'x64' : 'Win32';
            return util_1.format('IEDriverServer_%s_%s.zip', architecture, this.version);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IEConfig.prototype, "url", {
        get: function () {
            var majorMinorVersion = this.version.slice(0, this.version.lastIndexOf('.'));
            return util_1.format('%s/%s/%s', this.baseUrl, majorMinorVersion, this.artifact);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IEConfig.prototype, "executable", {
        get: function () {
            return 'IEDriverServer.exe';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IEConfig.prototype, "seleniumProperty", {
        get: function () {
            return 'webdriver.ie.driver';
        },
        enumerable: true,
        configurable: true
    });
    return IEConfig;
}(Config));
var EdgeVersions = {
    '15063': '342316D7-EBE0-4F10-ABA2-AE8E0CDF36DD',
    '16299': 'D417998A-58EE-4EFE-A7CC-39EF9E020768'
};
var EdgeConfig = (function (_super) {
    tslib_1.__extends(EdgeConfig, _super);
    function EdgeConfig(options) {
        return _super.call(this, lang_1.mixin({
            baseUrl: 'https://download.microsoft.com/download',
            version: '15063'
        }, options)) || this;
    }
    Object.defineProperty(EdgeConfig.prototype, "dontExtract", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "url", {
        get: function () {
            var uuid = this.uuid || EdgeVersions[this.version];
            var a = uuid[0];
            var b = uuid[1];
            var c = uuid[2];
            return util_1.format('%s/%s/%s/%s/%s/%s', this.baseUrl, a, b, c, uuid, this.executable);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "artifact", {
        get: function () {
            return 'MicrosoftWebDriver.exe';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "executable", {
        get: function () {
            return 'MicrosoftWebDriver.exe';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EdgeConfig.prototype, "seleniumProperty", {
        get: function () {
            return 'webdriver.edge.driver';
        },
        enumerable: true,
        configurable: true
    });
    return EdgeConfig;
}(Config));
var driverNameMap = {
    chrome: ChromeConfig,
    firefox: FirefoxConfig,
    ie: IEConfig,
    edge: EdgeConfig
};
//# sourceMappingURL=SeleniumTunnel.js.map