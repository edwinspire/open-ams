/// <reference types="node" />
import Evented from '@dojo/core/Evented';
import { EventObject, Handle } from '@dojo/core/interfaces';
import Task from '@dojo/core/async/Task';
import { ChildProcess } from 'child_process';
import { Url } from 'url';
import { JobState } from './interfaces';
export default class Tunnel extends Evented<TunnelEvents, string> implements TunnelProperties, Url {
    environmentUrl: string | undefined;
    accessKey: string | undefined;
    username: string | undefined;
    architecture: string;
    auth: string | undefined;
    directory: string;
    executable: string;
    hostname: string;
    pathname: string;
    platform: string;
    port: string;
    protocol: string;
    proxy: string | undefined;
    tunnelId: string | undefined;
    url: string;
    verbose: boolean;
    protected _startTask: Task<any> | undefined;
    protected _stopTask: Promise<number> | undefined;
    protected _handle: Handle | undefined;
    protected _process: ChildProcess | undefined;
    protected _state: 'stopped' | 'starting' | 'running' | 'stopping';
    constructor(options?: TunnelOptions);
    readonly clientUrl: string;
    readonly extraCapabilities: Object;
    readonly isDownloaded: boolean;
    readonly isRunning: boolean;
    readonly isStarting: boolean;
    readonly isStopping: boolean;
    download(forceDownload?: boolean): Task<void>;
    protected _downloadFile(url: string | undefined, proxy: string | undefined, options?: DownloadOptions): Task<void>;
    protected _postDownloadFile(data: Buffer, options?: DownloadOptions): Promise<void>;
    protected _makeArgs(..._values: string[]): string[];
    protected _makeChild(executor: ChildExecutor, ...values: string[]): Task<any>;
    protected _makeOptions(..._values: string[]): {
        env: NodeJS.ProcessEnv;
    };
    sendJobState(_jobId: string, _data: JobState): Task<void>;
    start(): Task<any>;
    protected _start(executor: ChildExecutor): Task<any>;
    stop(): Promise<number>;
    protected _stop(): Promise<number>;
    getEnvironments(): Task<NormalizedEnvironment[]>;
    protected _normalizeEnvironment(environment: Object): NormalizedEnvironment;
}
export interface TunnelEventObject<T> extends EventObject<string> {
    readonly target: T;
}
export interface TunnelEvents {
    stdout: IOEvent;
    stderr: IOEvent;
    status: StatusEvent;
    downloadprogress: DownloadProgressEvent;
    [index: string]: any;
}
export interface IOEvent extends TunnelEventObject<Tunnel> {
    readonly type: 'stdout' | 'stderr';
    readonly data: string;
}
export interface StatusEvent extends TunnelEventObject<Tunnel> {
    readonly type: 'status';
    readonly status: string;
}
export interface DownloadProgressEvent extends TunnelEventObject<Tunnel> {
    readonly type: 'downloadprogress';
    readonly url: string;
    readonly total: number;
    readonly received: number;
}
export interface ChildExecutor {
    (child: ChildProcess, resolve: () => void, reject: (reason?: any) => void): Handle | void;
}
export interface DownloadOptions {
    directory: string | undefined;
    proxy: string | undefined;
    url: string;
}
export interface NormalizedEnvironment {
    browserName: string;
    browserVersion?: string;
    descriptor: Object;
    platform: string;
    platformName?: string;
    platformVersion?: string;
    version: string;
    intern: {
        platform: string;
        browserName: string;
        version: string;
    };
}
export interface TunnelProperties extends DownloadOptions {
    architecture: string;
    auth: string | undefined;
    accessKey: string | undefined;
    executable: string | undefined;
    hostname: string;
    pathname: string;
    platform: string;
    port: string;
    protocol: string;
    tunnelId: string | undefined;
    username: string | undefined;
    verbose: boolean;
}
export declare type TunnelOptions = Partial<TunnelProperties>;
