{"version":3,"file":"parser.js","sourceRoot":"","sources":["parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tArrayExpression,\n\tAssignmentExpression,\n\tBaseFunction,\n\tExpression,\n\tNode,\n\tProperty,\n\tStatement,\n\tSwitchCase,\n\tVariableDeclaration\n} from 'estree';\n\n/**\n * If the provided node is an array expression, then return an array containing its values.\n * @private\n *\n * @param item An AST node\n * @return An array of values if the node is an array expression; otherwise, `undefined`.\n */\nexport function extractArrayValues(item: any) {\n\tif (!isArrayExpression(item)) {\n\t\treturn;\n\t}\n\treturn item.elements.map((element: any) => element.value);\n}\n\n/**\n * Return a parent node's child node, if it exists.\n *\n * @param item The parent node.\n * @return The child node, if it exists.\n */\nexport const getNextItem: (item: Node) => Node | null = (function () {\n\tconst getters = {\n\t\targument: (item: { argument: Expression | null }) => item.argument,\n\t\targuments: (item: { arguments: Expression[] }) => item.arguments,\n\t\tassignment: (item: AssignmentExpression) => item.right,\n\t\tbody: (item: { body: any }) => item.body,\n\t\tcall: (item: { callee: any, arguments: any[] }) => [ item.callee, ...(item.arguments || []) ],\n\t\t'case': (item: SwitchCase) => item.consequent,\n\t\tcases: (item: { cases: SwitchCase[] }) => item.cases,\n\t\tconditional: (item: { alternate: Expression; consequent: Expression; }) => [ item.alternate, item.consequent ],\n\t\telements: (item: { elements: Expression[] }) => item.elements,\n\t\texpression: (item: { expression: Expression }) => item.expression,\n\t\texpressions: (item: { expressions: Expression[] }) => item.expressions,\n\t\tloop: (item: { test: Expression; body: Statement; }) => [ item.test, item.body ],\n\t\tobject: (item: { object: Expression | null }) => item.object,\n\t\tproperties: (item: { properties: Property[] }) => item.properties,\n\t\tvalue: (item: { value: Expression }) => item.value\n\t};\n\n\tconst nextItemMap: { [key: string]: (item: any) => any; } = {\n\t\tArrayExpression: getters.elements,\n\t\tAssignmentExpression: getters.assignment,\n\t\tCallExpression: getters.call,\n\t\tConditionalExpression: getters.conditional,\n\t\tDoWhileStatement: getters.loop,\n\t\tExpressionStatement: getters.expression,\n\t\tIfStatement: getters.conditional,\n\t\tMemberExpression: getters.object,\n\t\tNewExpression: getters.arguments,\n\t\tObjectExpression: getters.properties,\n\t\tProperty: getters.value,\n\t\tReturnStatement: getters.argument,\n\t\tSequenceExpression: getters.expressions,\n\t\tSwitchCase: getters[ 'case' ],\n\t\tSwitchStatement: getters.cases,\n\t\tVariableDeclaration: (item: VariableDeclaration) => item.declarations,\n\t\tWhileStatement: getters.loop\n\t};\n\n\t[\n\t\t'ArrowExpression',\n\t\t'ArrowFunctionExpression',\n\t\t'BlockStatement',\n\t\t'ForInStatement',\n\t\t'ForOfStatement',\n\t\t'ForStatement',\n\t\t'FunctionDeclaration',\n\t\t'FunctionExpression',\n\t\t'LetStatement',\n\t\t'Program',\n\t\t'TryStatement'\n\n\t].forEach((type: string) => {\n\t\tnextItemMap[ type ] = getters.body;\n\t});\n\n\treturn function (item: Node): Node | null {\n\t\tif (!item) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst getter = nextItemMap[ item.type ];\n\t\treturn typeof getter === 'function' ? getter(item) : null;\n\t};\n})();\n\n/**\n * Determine whether the provided node is an array expression.\n * @private\n *\n * @param item The node to test.\n * @return `true` if the item is an array expression; false otherwise.\n */\nexport function isArrayExpression(item: any): item is ArrayExpression {\n\treturn item && item.type === 'ArrayExpression';\n}\n\n/**\n * Determine whether the provided node is a function declaration.\n * @private\n *\n * @param item The item to test.\n * @return `true` if the node represents either function declaration or a function expression.\n */\nexport function isFunctionDefinition(item: any): item is BaseFunction {\n\tif (!item) {\n\t\treturn false;\n\t}\n\n\tconst { type } = item;\n\treturn type === 'FunctionDeclaration' || type === 'ArrowFunctionExpression' || type === 'FunctionExpression';\n}\n\n/**\n * Determine whether the specified node is shadowing any of the specified variable names.\n * @private\n *\n * @param item The node to test\n * @param importNames A list of variable names.\n * @return `true` if the node is a shadowing node\n */\nexport function isShadowing(item: Node, importNames: string[]): boolean {\n\tif (isFunctionDefinition(item)) {\n\t\tconst { params } = item;\n\t\tconst paramNames = params.map((param: any) => param.name);\n\t\treturn paramNames.some((name: string) => importNames.indexOf(name) > -1);\n\t}\n\n\tif (item.type === 'BlockStatement') {\n\t\treturn item.body.filter((child: any) => child.type === 'VariableDeclaration')\n\t\t\t.some((child: any) => {\n\t\t\t\treturn child.declarations.some((declaration: any) => {\n\t\t\t\t\treturn importNames.indexOf(declaration.id.name) > -1 && (!declaration.init || !declaration.init.callee || declaration.init.callee.name !== 'require');\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\treturn false;\n}\n"]}