"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * If the provided node is an array expression, then return an array containing its values.
 * @private
 *
 * @param item An AST node
 * @return An array of values if the node is an array expression; otherwise, `undefined`.
 */
function extractArrayValues(item) {
    if (!isArrayExpression(item)) {
        return;
    }
    return item.elements.map((element) => element.value);
}
exports.extractArrayValues = extractArrayValues;
/**
 * Return a parent node's child node, if it exists.
 *
 * @param item The parent node.
 * @return The child node, if it exists.
 */
exports.getNextItem = (function () {
    const getters = {
        argument: (item) => item.argument,
        arguments: (item) => item.arguments,
        assignment: (item) => item.right,
        body: (item) => item.body,
        call: (item) => [item.callee, ...(item.arguments || [])],
        'case': (item) => item.consequent,
        cases: (item) => item.cases,
        conditional: (item) => [item.alternate, item.consequent],
        elements: (item) => item.elements,
        expression: (item) => item.expression,
        expressions: (item) => item.expressions,
        loop: (item) => [item.test, item.body],
        object: (item) => item.object,
        properties: (item) => item.properties,
        value: (item) => item.value
    };
    const nextItemMap = {
        ArrayExpression: getters.elements,
        AssignmentExpression: getters.assignment,
        CallExpression: getters.call,
        ConditionalExpression: getters.conditional,
        DoWhileStatement: getters.loop,
        ExpressionStatement: getters.expression,
        IfStatement: getters.conditional,
        MemberExpression: getters.object,
        NewExpression: getters.arguments,
        ObjectExpression: getters.properties,
        Property: getters.value,
        ReturnStatement: getters.argument,
        SequenceExpression: getters.expressions,
        SwitchCase: getters['case'],
        SwitchStatement: getters.cases,
        VariableDeclaration: (item) => item.declarations,
        WhileStatement: getters.loop
    };
    [
        'ArrowExpression',
        'ArrowFunctionExpression',
        'BlockStatement',
        'ForInStatement',
        'ForOfStatement',
        'ForStatement',
        'FunctionDeclaration',
        'FunctionExpression',
        'LetStatement',
        'Program',
        'TryStatement'
    ].forEach((type) => {
        nextItemMap[type] = getters.body;
    });
    return function (item) {
        if (!item) {
            return null;
        }
        const getter = nextItemMap[item.type];
        return typeof getter === 'function' ? getter(item) : null;
    };
})();
/**
 * Determine whether the provided node is an array expression.
 * @private
 *
 * @param item The node to test.
 * @return `true` if the item is an array expression; false otherwise.
 */
function isArrayExpression(item) {
    return item && item.type === 'ArrayExpression';
}
exports.isArrayExpression = isArrayExpression;
/**
 * Determine whether the provided node is a function declaration.
 * @private
 *
 * @param item The item to test.
 * @return `true` if the node represents either function declaration or a function expression.
 */
function isFunctionDefinition(item) {
    if (!item) {
        return false;
    }
    const { type } = item;
    return type === 'FunctionDeclaration' || type === 'ArrowFunctionExpression' || type === 'FunctionExpression';
}
exports.isFunctionDefinition = isFunctionDefinition;
/**
 * Determine whether the specified node is shadowing any of the specified variable names.
 * @private
 *
 * @param item The node to test
 * @param importNames A list of variable names.
 * @return `true` if the node is a shadowing node
 */
function isShadowing(item, importNames) {
    if (isFunctionDefinition(item)) {
        const { params } = item;
        const paramNames = params.map((param) => param.name);
        return paramNames.some((name) => importNames.indexOf(name) > -1);
    }
    if (item.type === 'BlockStatement') {
        return item.body.filter((child) => child.type === 'VariableDeclaration')
            .some((child) => {
            return child.declarations.some((declaration) => {
                return importNames.indexOf(declaration.id.name) > -1 && (!declaration.init || !declaration.init.callee || declaration.init.callee.name !== 'require');
            });
        });
    }
    return false;
}
exports.isShadowing = isShadowing;
//# sourceMappingURL=parser.js.map