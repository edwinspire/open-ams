"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const NormalModule = require("webpack/lib/NormalModule");
const main_1 = require("./util/main");
const Map_1 = require("@dojo/shim/Map");
require("@dojo/shim/Promise");
const basePath = path.join(process.cwd(), 'node_modules');
/**
 * @private
 * Generate the request and loader data for the specified module ID within the specified context.
 *
 * @param id
 * The module ID.
 *
 * @param absContext
 * The context used when the module ID is absolute.
 *
 * @param relativeContext
 * The context used when the module ID is relative.
 *
 * @param resolver
 * The resolver function.
 *
 * @return
 * A promise to the resolved module paths data.
 */
function resolveContextPath(id, absContext, relativeContext, resolver) {
    return new Promise((resolve, reject) => {
        resolver({
            contextInfo: {},
            context: main_1.isRelative(id) ? relativeContext : absContext,
            request: id
        }, (error, result) => {
            if (error) {
                return reject(error);
            }
            resolve(result);
        });
    });
}
/**
 * @private
 * Resolve the default context to use when resolving the IDs for any injected modules.
 *
 * @param plugin
 * The plugin instance.
 *
 * @param compiler
 * The compiler instance.
 */
function setContext(plugin, compiler) {
    if (plugin.context) {
        return;
    }
    const resolve = compiler.options.resolve;
    const modules = resolve && resolve.modules;
    plugin.context = Array.isArray(modules) ? modules[0] :
        (typeof modules === 'string') ? modules : basePath;
}
/**
 * @private
 * Validate the presence of module IDs.
 *
 * @param module IDs
 * The module ID array or hash to validate.
 *
 * @throws Error
 */
function validateModuleIds(moduleIds) {
    const length = Array.isArray(moduleIds) ?
        moduleIds.length :
        Object.keys(moduleIds).reduce((length, context) => {
            return length + moduleIds[context].length;
        }, 0);
    if (!length) {
        throw new Error('Missing module IDs.');
    }
}
/**
 * A webpack plugin that injects arbitrary modules into the relevant build chunks if a module matching a specified
 * pattern is included somewhere in the current module hierarchy.
 */
class InjectModulesPlugin {
    constructor(options) {
        const { context, moduleIds, resourcePattern } = options;
        validateModuleIds(moduleIds);
        this._added = [];
        this._modules = new Map_1.default();
        this.context = context;
        this.moduleIds = moduleIds;
        this.resourcePattern = resourcePattern;
    }
    /**
     * Set up the compiler and compilation event listeners.
     *
     * @param compiler
     * The compiler instance.
     */
    apply(compiler) {
        const { resourcePattern } = this;
        const resources = [];
        setContext(this, compiler);
        compiler.plugin('compilation', (compilation, data) => {
            // Listening to the "resolver" event gives access to the resolver function that allows the injected module
            // IDs to be mapped to not only their resources, but also to any loaders.
            data.normalModuleFactory.plugin('resolver', (resolver) => {
                return (data, callback) => {
                    resolver(data, (error, result) => {
                        if (error) {
                            return callback(error);
                        }
                        const { resource } = result;
                        if (resourcePattern.test(resource) && resources.indexOf(resource) === -1) {
                            return this.resolve(resource, resolver)
                                .then(resolved => {
                                resources.push(resource);
                                return this.createModules(resolved, compilation);
                            })
                                .then(() => {
                                callback(null, result);
                            })
                                .catch((error) => {
                                callback(error);
                            });
                        }
                        callback(null, result);
                    });
                };
            });
            compilation.plugin('optimize-chunks', (chunks) => {
                this._modules.forEach((module) => {
                    chunks.forEach((chunk) => {
                        const requests = chunk.modules.map((module) => module.userRequest);
                        if (requests.some((id) => resources.indexOf(id) > -1)) {
                            chunk.addModule(module);
                            module.addChunk(chunk);
                            this.injectModuleDependencies(module, chunk);
                        }
                    });
                });
            });
        });
        compiler.plugin('done', () => {
            this._added.length = 0;
        });
    }
    /**
     * Generate and build the module instances, and then inject them into the current compilation.
     *
     * @param data
     * An array of resolved request data used to generate the module object.
     *
     * @param compilation
     * The current compilation.
     *
     * @return
     * A promise that resolves once all modules have been built.
     */
    createModules(data, compilation) {
        return Promise.all(data.map(item => {
            return new Promise((resolve, reject) => {
                const { request, userRequest, rawRequest, loaders, resource, parser } = item;
                let module = this._modules.get(resource);
                if (!module) {
                    module = new NormalModule(request, userRequest, rawRequest, loaders, resource, parser);
                    this._modules.set(resource, module);
                }
                compilation.addModule(module);
                compilation.buildModule(module, false, null, null, (error) => {
                    if (error) {
                        return reject(error);
                    }
                    compilation.processModuleDependencies(module, (error) => {
                        if (error) {
                            return reject(error);
                        }
                        resolve();
                    });
                });
            });
        }));
    }
    injectModuleDependencies(module, chunk) {
        if (this._added.indexOf(module.userRequest) > -1) {
            return;
        }
        this._added.push(module.userRequest);
        module.dependencies.forEach(dependency => {
            const modules = Array.isArray(dependency.module) ? dependency.module : [dependency.module];
            modules.filter(module => Boolean(module))
                .forEach(module => {
                chunk.addModule(module);
                module.addChunk(chunk);
                this.injectModuleDependencies(module, chunk);
            });
        });
    }
    /**
     * Resolve the request data for all modules injected for the specified resource.
     *
     * @param resource
     * The context for the injected modules.
     *
     * @param resolver
     * The resolver function.
     *
     * @return
     * A promise that resolves to the request data for the injected modules.
     */
    resolve(resource, resolver) {
        const { context, moduleIds } = this;
        const resourcePath = main_1.getBasePath(resource);
        if (Array.isArray(moduleIds)) {
            return Promise.all(moduleIds.map((id) => {
                return resolveContextPath(id, context, resourcePath, resolver);
            }));
        }
        else {
            return Promise.all(Object.keys(moduleIds).reduce((promises, context) => {
                return promises.concat(moduleIds[context].map((id) => {
                    return resolveContextPath(id, context, resourcePath, resolver);
                }));
            }, []));
        }
    }
}
exports.default = InjectModulesPlugin;
//# sourceMappingURL=InjectModulesPlugin.js.map