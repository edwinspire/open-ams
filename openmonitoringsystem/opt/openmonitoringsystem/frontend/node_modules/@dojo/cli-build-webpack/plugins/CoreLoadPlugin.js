"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const main_1 = require("./util/main");
const parser_1 = require("./util/parser");
const Set_1 = require("@dojo/shim/Set");
const ConcatSource = require("webpack-sources/lib/ConcatSource");
const NormalModuleReplacementPlugin = require("webpack/lib/NormalModuleReplacementPlugin");
const RequireEnsureDependenciesBlock = require('webpack/lib/dependencies/RequireEnsureDependenciesBlock');
const RequireEnsureItemDependency = require('webpack/lib/dependencies/RequireEnsureItemDependency');
const ConstDependency = require('webpack/lib/dependencies/ConstDependency');
/**
 * @private
 * Regular expression that matches JS module IDs.
 */
const jsMidPattern = /\.(t|j)sx?$/;
/**
 * @private
 * Regular expression that matches a relative path, regardless of the file separator.
 */
const relativePathPattern = main_1.createFilePathRegExp('^\\.(\\.*)\/');
/**
 * @private
 * Test whether a module was required with a relative mid and is relative to a module with a contextual require.
 *
 * @param module
 * The module to test.
 *
 * @param issuers
 * The userRequest paths for all modules with a contextual require.
 *
 * @return
 * True if the module should be included in the load map; false otherwise.3u
 */
function isContextual(module, issuers) {
    const { rawRequest, userRequest } = module;
    const request = userRequest.replace(/\.[a-z0-9]+$/i, '');
    return relativePathPattern.test(rawRequest) && issuers.some((issuer) => path.resolve(issuer, rawRequest) === path.resolve(request));
}
/**
 * @private
 * Strips the drive prefix from a file path and normalizes the path separator to '/'.
 *
 * @param path The path on which to operate.
 *
 * @return The normalized file path.
 */
function normalizeFilePath(path) {
    return path.replace(/\\/g, '/').replace(/^[a-z]:/i, '');
}
/**
 * @private
 * Remove the specified base path from the specified path. If the path begins with the base path, then also remove
 * the node_modules path segment. Note that the file separator of the returned path is converted to '/'.
 *
 * @param basePath
 * The base path.
 *
 * @param path
 * The path to modify.
 *
 * @return
 * The updated path.
 */
function stripPath(basePath, path) {
    basePath = normalizeFilePath(basePath);
    path = normalizeFilePath(path);
    let resolved = (basePath ? path.replace(basePath + '/', '') : path).replace(/\..*$/, '');
    if (path.indexOf(basePath) === 0) {
        resolved = resolved.replace('node_modules/', '');
    }
    return resolved;
}
/**
 * Iterate through a Statement and find all the CallExpressions. The call expression and the
 * AST path to the expressio is saved.
 *
 * @param statement The program/statement to get the call expressions for
 * @return The array of call expressions including the parent
 */
function findCallExpressions(statement) {
    const callExpressions = [];
    function walker(path, item) {
        if (!item) {
            return;
        }
        if (item instanceof Array) {
            item.forEach(arrayItem => walker([...path, item], arrayItem));
            return;
        }
        else if (item.type === 'CallExpression') {
            callExpressions.push({
                callExpression: item,
                path: path
            });
        }
        const next = parser_1.getNextItem(item);
        next && walker([...path, item], next);
    }
    walker([], statement);
    return callExpressions;
}
/**
 * A webpack plugin that forces webpack to ignore `require` passed as a value, and replaces `@dojo/core/load` with a
 * custom function that maps string module IDs to webpack's numerical module IDs.
 */
class DojoLoadPlugin {
    constructor(options = {}) {
        this._ignoredModules = new Set_1.default();
        const { basePath = './', chunkNames = {}, detectLazyLoads = false, ignoredModules, mapAppModules = false } = options;
        this._basePath = normalizeFilePath(basePath);
        this._detectLazyLoads = detectLazyLoads;
        this._lazyChunkNames = chunkNames;
        this._mapAppModules = mapAppModules;
        if (ignoredModules) {
            ignoredModules.forEach(moduleName => {
                const absolutePath = path.resolve(basePath, moduleName);
                this._ignoredModules.add(absolutePath);
            });
        }
    }
    /**
     * Set up event listeners on the compiler and compilation. Register any module that uses a contextual require,
     * replace use of `@dojo/core/load` with a custom load module, passing it a map of all dynamically-required
     * module IDs.
     *
     * @param compiler
     * The compiler instance.
     */
    apply(compiler) {
        const idMap = Object.create(null);
        const basePath = this._basePath;
        const bundleLoader = /bundle.*\!/;
        const issuers = [];
        const detectLazyLoads = this._detectLazyLoads;
        const chunkNames = this._lazyChunkNames;
        const ignoredModules = this._ignoredModules;
        const coreLoadPattern = main_1.createFilePathRegExp('@dojo/core/load\\.js');
        compiler.apply(new NormalModuleReplacementPlugin(coreLoadPattern, main_1.resolveMid('@dojo/core/load/webpack')));
        compiler.plugin('compilation', (compilation, params) => {
            params.normalModuleFactory.plugin('parser', function (parser) {
                parser.plugin('expression require', function () {
                    const state = this.state;
                    if (state && state.current && state.current.meta) {
                        issuers.push(main_1.getBasePath(state.current.userRequest));
                        state.current.meta.isPotentialLoad = true;
                        return true;
                    }
                    return false;
                });
                if (detectLazyLoads) {
                    /*
                     Detect lazy loads by iterating through a module and looking for a pattern,
                     call_expression(require, 'some string')
                     */
                    parser.plugin('program', function (program) {
                        if (parser.state && parser.state.current) {
                            const { userRequest } = parser.state.current;
                            if (userRequest) {
                                const source = parser.state.module._source;
                                if (!source || source.source().indexOf('@dojo/core/load') === -1) {
                                    return;
                                }
                                findCallExpressions(program).filter(expression => expression.callExpression.arguments.length === 2).forEach(callExpressionAndParent => {
                                    const [first, second] = callExpressionAndParent.callExpression.arguments;
                                    if (first.type === 'Identifier' && first.name === 'require') {
                                        if (second.type === 'Literal' && typeof (second.value) === 'string') {
                                            const callPath = [...callExpressionAndParent.path];
                                            const absolutePath = path.resolve(path.dirname(userRequest), second.value);
                                            if (ignoredModules.has(absolutePath)) {
                                                return;
                                            }
                                            let foundDefineCall = false;
                                            let index = callPath.length - 1;
                                            while (index > 0) {
                                                const entry = callPath[index--];
                                                if (entry.type === 'CallExpression') {
                                                    if (entry.callee.type === 'MemberExpression' && entry.callee.property.type === 'Identifier' && entry.callee.property.name === 'define') {
                                                        foundDefineCall = true;
                                                        break;
                                                    }
                                                }
                                            }
                                            /*
                                            We only want to process calls that were made inside of a `registry.define` call.
                                             */
                                            if (!foundDefineCall) {
                                                return;
                                            }
                                            /*
                                             Find the containing function of the expression. We'll want this whole
                                             function to be wrapped in the require.ensure
                                             */
                                            let fnExpression = callPath.pop();
                                            while (fnExpression && fnExpression.type !== 'FunctionExpression') {
                                                fnExpression = callPath.pop();
                                            }
                                            /*
                                             The require.ensure plugin expects you to actually be calling require.ensure,
                                             which has a signature like require.ensure([], function() { }). We need to mock
                                             the plugin has a hard coded check on 'expression.arguments[1]' to get a handle
                                             to the actual function we want to ensure, so we need to make a pretend expression
                                             that looks like a require.ensure call.
                                             */
                                            const temp = {
                                                type: 'CallExpression',
                                                arguments: [
                                                    {},
                                                    fnExpression
                                                ],
                                                range: fnExpression.range
                                            };
                                            /*
                                             Find an appropriate chunk name (null is an appropriate chunk name).
                                             */
                                            let chunkName = path.basename(absolutePath);
                                            const applicableNames = Object.keys(chunkNames).filter(name => {
                                                return chunkNames[name].test(second.value);
                                            });
                                            if (applicableNames.length > 0) {
                                                chunkName = applicableNames[0];
                                            }
                                            /*
                                             Create the require.ensure block
                                             */
                                            const dep = new RequireEnsureDependenciesBlock(temp, fnExpression, null, chunkName, null, parser.state.module, fnExpression.loc);
                                            const old = parser.state.current;
                                            parser.state.current = dep;
                                            /*
                                             We add our one dependency to the [] in the ensure
                                             */
                                            parser.inScope([], () => {
                                                const edep = new RequireEnsureItemDependency(second.value, second.range);
                                                edep.loc = dep.loc;
                                                dep.addDependency(edep);
                                            });
                                            /*
                                             By default, the require.ensure is not going to execute when we want. We wrap it in a function block
                                             to control the execution.
                                             */
                                            old.addDependency(new ConstDependency('function() { return (', fnExpression.range[0]));
                                            old.addDependency(new ConstDependency('})', fnExpression.range[1] + 1));
                                            old.addBlock(dep);
                                            parser.state.current = old;
                                        }
                                    }
                                });
                            }
                        }
                    });
                }
            });
            compilation.moduleTemplate.plugin('module', (source, module) => {
                if (module.meta && module.meta.isPotentialLoad) {
                    const path = stripPath(basePath, module.userRequest);
                    const require = `var require = function () { return '${path}'; };`;
                    return new ConcatSource(require, '\n', source);
                }
                const load = idMap['@dojo/core/load'] || { id: null };
                if (module.id === load.id) {
                    const moduleMap = `var __modules__ = ${JSON.stringify(idMap)};`;
                    return new ConcatSource(moduleMap, '\n', source);
                }
                return source;
            });
            compilation.plugin('optimize-module-ids', (modules) => {
                const appPath = this._basePath ? path.join(this._basePath, 'src') : 'src';
                function mapModuleId(modulePath, module) {
                    const { rawRequest, userRequest } = module;
                    let lazy = false;
                    if (bundleLoader.test(rawRequest)) {
                        const afterLoader = userRequest.split('!')[1];
                        modulePath = stripPath(basePath, afterLoader);
                        lazy = true;
                    }
                    idMap[modulePath] = { id: module.id, lazy };
                }
                modules.forEach(module => {
                    let { rawRequest, userRequest } = module;
                    if (rawRequest) {
                        rawRequest = normalizeFilePath(rawRequest);
                        userRequest = normalizeFilePath(userRequest);
                        if (this._mapAppModules && path.resolve(userRequest).indexOf(path.resolve(appPath)) === 0) {
                            if (jsMidPattern.test(userRequest)) {
                                let modulePath = userRequest.replace(`${this._basePath}/`, '').replace(jsMidPattern, '');
                                mapModuleId(modulePath, module);
                            }
                        }
                        else if (rawRequest.indexOf('@dojo') === 0 || !/^\W/.test(rawRequest)) {
                            let modulePath = rawRequest;
                            mapModuleId(modulePath, module);
                        }
                        else if (isContextual(module, issuers)) {
                            const modulePath = stripPath(basePath, userRequest);
                            idMap[modulePath] = { id: module.id, lazy: false };
                        }
                    }
                });
            });
        });
    }
}
exports.default = DojoLoadPlugin;
;
//# sourceMappingURL=CoreLoadPlugin.js.map