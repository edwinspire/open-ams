"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Map_1 = require("@dojo/shim/Map");
const path = require("path");
const main_1 = require("./main");
const parser_1 = require("./parser");
/**
 * @private
 * Determines whether the provided expression is a CallExpression.
 */
function isCallExpression(expression) {
    return expression && expression.type === 'CallExpression';
}
/**
 * @private
 * Determines whether the provided expression is a SequenceExpression.
 */
function isSequenceExpression(expression) {
    return expression && expression.type === 'SequenceExpression';
}
/**
 * @private
 * Resolves the callee and arguments for the provided expression.
 *
 * @param expression An AST expression node.
 * @return An object containing the callee and arguments if the expression is a call expression.
 */
function getCallExpressionData(expression) {
    if (isSequenceExpression(expression)) {
        const callExpressions = expression.expressions.filter(expression => isCallExpression(expression));
        expression = callExpressions[0];
    }
    if (!expression) {
        return {};
    }
    const { callee, arguments: args } = expression;
    return { callee, args };
}
/**
 * Return an array of URLs that are passed as arguments to `@dojo/i18n/cldr/load.default` in the specified AST program
 * and with the specified import variable names.
 *
 * @param ast
 * An AST program to parse
 *
 * @param importNames
 * The variables name(s) in the AST program that represent the `@dojo/i18n/cldr/load.default` function.
 * In the overwhelming majority of use cases, there will only be one.
 *
 * @return
 * An array of containing all the string URLs that were passed to the cldr/load function.
 */
exports.getLoadCallUrls = (function () {
    // A map of AST nodes to their parent nodes, used to recursively walk back up the tree when a variable
    // is passed to `@dojo/i18n/cldr/load.default`.
    const treeMap = new Map_1.default();
    /**
     * @private
     * Recursively walk the provided AST tree, extracting URL arrays passed to `@dojo/i18n/core/load`.
     */
    function getLoadCallUrls(item, importNames, urls = []) {
        if (!item || importNames.length === 0) {
            return urls;
        }
        if (Array.isArray(item)) {
            return item.reduce((urls, child) => {
                treeMap.set(child, item);
                return getLoadCallUrls(child, importNames, urls);
            }, urls);
        }
        else {
            // If the node in question is redefining our `load.default`, ignore the entire node.
            if (parser_1.isShadowing(item, importNames)) {
                return urls;
            }
            if (item.type === 'CallExpression') {
                if (item.callee.type === 'MemberExpression' && testMemberExpression(item.callee, importNames)) {
                    const arg = item.arguments.length > 1 ? item.arguments[1] : item.arguments[0];
                    const argArray = parser_1.extractArrayValues(arg);
                    if (argArray) {
                        urls = main_1.mergeUnique(urls, argArray);
                    }
                    else if (arg && arg.type === 'Identifier') {
                        // walk up the tree to find the first value with the given name.
                        const value = findFirstValue(item, arg.name);
                        if (value) {
                            const argArray = parser_1.extractArrayValues(value.init);
                            if (argArray) {
                                urls = main_1.mergeUnique(urls, argArray);
                            }
                        }
                    }
                }
            }
            const nextItem = parser_1.getNextItem(item);
            treeMap.set(nextItem, item);
            return getLoadCallUrls(nextItem, importNames, urls);
        }
    }
    /**
     * @private
     * Walk back up the AST tree from the specified node, looking for a variable with the provided name.
     */
    function findFirstValue(item, name) {
        let parent = treeMap.get(item);
        while (parent) {
            const variableDeclaration = getMatchingVariableDeclaration(parent, name);
            if (variableDeclaration) {
                return variableDeclaration;
            }
            parent = treeMap.get(parent);
        }
    }
    /**
     * @private
     * Return the first variable declarations whos name matches the provided name.
     *
     * @param item
     * An AST node, or an array of AST nodes, to inspect.
     *
     * @param name
     * A variable name.
     *
     * @return
     * The variable declaration with the specified name if it exists, `undefined` if it does not.
     */
    function getMatchingVariableDeclaration(item, name) {
        if (Array.isArray(item)) {
            for (let i = 0; i < item.length; i++) {
                const result = getMatchingVariableDeclaration(item[i], name);
                if (result) {
                    return result;
                }
            }
        }
        else if (item.type === 'VariableDeclaration') {
            const matching = item.declarations.filter((declaration) => declaration.id.name === name);
            return matching[0];
        }
    }
    /**
     * @private
     * Determine whether the specified member expression represents the `default` value on the
     * on an object with at least one of the specified variable names.
     *
     * For example, if `importNames` is `[ 'loadCldrData' ]`, then a call to `loadCldrData.default` will match.
     *
     * @param item
     * A MemberExpression node
     *
     * @param importNames
     * A list of variable names.
     *
     * @return
     * `true` if the test passes; `false` otherwise.
     */
    function testMemberExpression(item, importNames) {
        const { object, property } = item;
        return importNames.indexOf(object.name) > -1 && property.name === 'default';
    }
    return function (program, importNames) {
        const urls = getLoadCallUrls(program, importNames);
        treeMap.clear();
        return urls;
    };
})();
/**
 * Return an array of variable names for `@dojo/i18n/cldr/load` imports.
 *
 * @param ast
 * An AST program to parse.
 *
 * @return
 * A list of variable names.
 */
function getLoadImports(ast) {
    return ast.body.filter(item => item.type === 'VariableDeclaration')
        .reduce((a, b) => {
        return a.concat(b.declarations);
    }, [])
        .filter(((item) => {
        const expression = item.init;
        const { callee, args } = getCallExpressionData(expression);
        return callee && callee.name === 'require' && args && args.length === 1 && /cldr\/load/.test(args[0].value);
    }))
        .map(item => item.id.name);
}
exports.getLoadImports = getLoadImports;
/**
 * Parse an AST program for all URLs passed to `@dojo/i18n/cldr/load`.
 *
 * Note that `@dojo/i18n/cldr/load` must be loaded with `require` for it to be recognized.
 * URLs can be injected as an array either directly to cldr/load function, or via a variable that is defined within
 * the same program. If a variable is used, then its definition MUST be a straightforward array expression:
 * `const cldrUrls = [ ... ]`. More complex operatiions will not be registered (for example:
 * `const supplemental = [ 'likelySubtags' ].map(name => `cldr-data/supplemental/${name}.json`).
 *
 * @param ast
 * An AST program
 *
 * @return
 * An array of any URLs parsed from calls to `@dojo/i18n/cldr/load.default`.
 */
function getCldrUrls(context, ast) {
    const importNames = getLoadImports(ast);
    const urls = exports.getLoadCallUrls(ast, importNames);
    return urls.map((url) => {
        return main_1.isRelative(url) ? path.resolve(main_1.getBasePath(context), url) : url;
    });
}
exports.default = getCldrUrls;
//# sourceMappingURL=i18n.js.map