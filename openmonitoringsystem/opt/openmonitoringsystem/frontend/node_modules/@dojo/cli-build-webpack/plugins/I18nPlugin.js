"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lang_1 = require("@dojo/core/lang");
const Map_1 = require("@dojo/shim/Map");
const Set_1 = require("@dojo/shim/Set");
const fs = require("fs");
const path = require("path");
const ConcatSource = require("webpack-sources/lib/ConcatSource");
const NormalModuleReplacementPlugin = require("webpack/lib/NormalModuleReplacementPlugin");
const InjectModulesPlugin_1 = require("./InjectModulesPlugin");
const i18n_1 = require("./util/i18n");
const main_1 = require("./util/main");
const cldrLoadWebpackPattern = main_1.createFilePathRegExp('cldr/load(/webpack|\\.js)');
/**
 * @private
 * Return a list of locale-specific message bundle paths for the provided bundle ID and supported locales.
 * Only paths for existing modules are included.
 *
 * @param bundle
 * The default bundle module ID or path.
 *
 * @param supportedLocales
 * The list of supported locales.
 *
 * @return
 * The list of paths for the locale-specific message bundles.
 */
function getMessageLocalePaths(bundle, supportedLocales) {
    const idSegments = bundle.split('/');
    const base = idSegments.slice(0, -1).join('/');
    const name = idSegments.slice(-1).join();
    const extension = main_1.hasExtension(name) ? '' : '.ts';
    return supportedLocales
        .map((locale) => path.join(base, locale, name))
        .filter((path) => {
        try {
            fs.accessSync(`${path}${extension}`);
            return true;
        }
        catch (error) {
            return false;
        }
    });
}
/**
 * @private
 * Determine whether the specified path is for the `@dojo/i18n/cldr/load` module.
 */
function isCldrLoadModule(path) {
    return cldrLoadWebpackPattern.test(path);
}
/**
 * @private
 * Determine whether the specified module path is for a JavaScript/TypeScript module.
 */
function isJsModule(mid) {
    return /\.(j|t)sx?$/.test(mid);
}
/**
 * @private
 * Determine whether the specified module path is for a node module.
 */
function isNodeModule(mid) {
    return mid.indexOf('node_modules') > -1;
}
/**
 * A webpack plugin that ensures CLDR data and locale-specific messages are available to webpack.
 */
class DojoI18nPlugin {
    constructor(options) {
        const { cacheCldrUrls, defaultLocale, messageBundles, supportedLocales } = options;
        this.defaultLocale = defaultLocale;
        this.messageBundles = messageBundles;
        this.supportedLocales = supportedLocales;
        if (cacheCldrUrls) {
            this._cldrUrls = [];
        }
    }
    /**
     * Add messages and CLDR data to the build, and replace `@dojo/i18n/cldr/load` with a webpack-specific
     * load module.
     *
     * @param compiler
     * The current compiler.
     */
    apply(compiler) {
        const { messageBundles, supportedLocales } = this;
        const cldrLoadPattern = main_1.createFilePathRegExp('/cldr/load($|\\.js)');
        compiler.apply(new NormalModuleReplacementPlugin(cldrLoadPattern, main_1.resolveMid('@dojo/i18n/cldr/load/webpack')));
        if (supportedLocales && messageBundles && messageBundles.length) {
            messageBundles.forEach(bundle => {
                const localePaths = getMessageLocalePaths(bundle, supportedLocales);
                if (localePaths.length) {
                    compiler.apply(new InjectModulesPlugin_1.default({
                        resourcePattern: main_1.createFilePathRegExp(bundle),
                        moduleIds: localePaths
                    }));
                }
            });
        }
        compiler.plugin('compilation', (compilation, data) => {
            const astMap = new Map_1.default();
            const containsLoad = [];
            const contextMap = new Map_1.default();
            // An internal set of all fully-resolved module paths, used to determine whether a module path
            // should be added to the issuer map (see below). This exists entirely for performance reasons,
            // specifically to reduce the number of AST objects held in memory. Since modules are parsed only
            // once, this is needed to ensure the issuer map decrementer works correctly.
            const moduleSet = new Set_1.default();
            // An internal map of issuer paths to an array of fully-resolved dependency paths.
            // This map exists entirely for performance reasons, specifically to reduce the number of AST
            // objects held in memory.
            const issuerMap = new Map_1.default();
            data.normalModuleFactory.plugin('before-resolve', (result, callback) => {
                if (!result) {
                    return callback();
                }
                const { context, contextInfo, request } = result;
                const issuer = contextInfo && contextInfo.issuer;
                if (issuer && !isNodeModule(issuer)) {
                    let requestData = contextMap.get(context);
                    if (!requestData) {
                        requestData = [];
                        contextMap.set(context, requestData);
                    }
                    requestData.push({ issuer, request });
                }
                return callback(null, result);
            });
            data.normalModuleFactory.plugin('after-resolve', (result, callback) => {
                if (!result) {
                    return callback();
                }
                const { context, rawRequest, userRequest } = result;
                const requestData = contextMap.get(context);
                if (requestData) {
                    const issuer = requestData.filter((item) => item.request === rawRequest)
                        .map(item => item.issuer)[0];
                    let issuerData = issuerMap.get(issuer);
                    if (!issuerData) {
                        issuerData = [];
                        issuerMap.set(issuer, issuerData);
                    }
                    if (isJsModule(userRequest)) {
                        if (!moduleSet.has(userRequest)) {
                            issuerData.push(userRequest);
                            moduleSet.add(userRequest);
                        }
                        if (isCldrLoadModule(userRequest)) {
                            containsLoad.push(issuer);
                        }
                    }
                }
                return callback(null, result);
            });
            data.normalModuleFactory.plugin('parser', (parser) => {
                parser.plugin('program', (ast) => {
                    const { issuer, userRequest } = parser.state.current;
                    if (userRequest) {
                        if (!isNodeModule(userRequest) && isJsModule(userRequest)) {
                            astMap.set(userRequest, ast);
                        }
                        /* istanbul ignore next: internal performance enhancement that has no effect on output */
                        if (issuer && issuer.userRequest) {
                            const issuerData = issuerMap.get(issuer.userRequest);
                            if (issuerData) {
                                const index = issuerData.indexOf(userRequest);
                                if (index > -1) {
                                    issuerData.splice(index, 1);
                                }
                                if (issuerData.length === 0) {
                                    issuerMap.delete(issuer.userRequest);
                                    if (containsLoad.indexOf(issuer.userRequest) < 0) {
                                        astMap.delete(issuer.userRequest);
                                    }
                                }
                            }
                        }
                    }
                });
            });
            compilation.moduleTemplate.plugin('module', (source, module) => {
                if (isCldrLoadModule(module.userRequest)) {
                    const locales = this._getLocales();
                    let cldrUrls = containsLoad.map((path) => i18n_1.default(path, astMap.get(path)))
                        .reduce(main_1.mergeUnique, [])
                        .map((url) => {
                        return locales.map((locale) => url.replace('{locale}', locale));
                    })
                        .reduce(main_1.mergeUnique, []);
                    if (this._cldrUrls) {
                        cldrUrls = this._cldrUrls = main_1.mergeUnique(this._cldrUrls, cldrUrls);
                    }
                    const cldrData = cldrUrls.map((mid) => require(mid))
                        .reduce((cldrData, source) => {
                        return lang_1.deepAssign(cldrData, source);
                    }, Object.create(null));
                    return new ConcatSource(`var __cldrData__ = ${JSON.stringify(cldrData)}`, '\n', source);
                }
                return source;
            });
        });
    }
    /**
     * @protected
     * Returns a merged array of supported locales.
     */
    _getLocales() {
        const { defaultLocale, supportedLocales } = this;
        const locales = [defaultLocale];
        return Array.isArray(supportedLocales) ? locales.concat(supportedLocales) : locales;
    }
}
exports.default = DojoI18nPlugin;
//# sourceMappingURL=I18nPlugin.js.map