{"version":3,"file":"i18n.js","sourceRoot":"","sources":["i18n.ts"],"names":[],"mappings":"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","sourcesContent":["import Map from '@dojo/shim/Map';\nimport { CallExpression, Expression, Identifier, Program, SequenceExpression, SpreadElement, VariableDeclaration, VariableDeclarator } from 'estree';\nimport * as path from 'path';\nimport { getBasePath, isRelative, mergeUnique } from './main';\nimport { extractArrayValues, getNextItem, isShadowing } from './parser';\n\n/**\n * @private\n * Determines whether the provided expression is a CallExpression.\n */\nfunction isCallExpression(expression: any): expression is CallExpression {\n\treturn expression && expression.type === 'CallExpression';\n}\n\n/**\n * @private\n * Determines whether the provided expression is a SequenceExpression.\n */\nfunction isSequenceExpression(expression: any): expression is SequenceExpression {\n\treturn expression && expression.type === 'SequenceExpression';\n}\n\n/**\n * @private\n * Resolves the callee and arguments for the provided expression.\n *\n * @param expression An AST expression node.\n * @return An object containing the callee and arguments if the expression is a call expression.\n */\nfunction getCallExpressionData(expression?: any): { callee?: Identifier, args?: Array<Expression | SpreadElement> } {\n\tif (isSequenceExpression(expression)) {\n\t\tconst callExpressions = expression.expressions.filter(expression => isCallExpression(expression)) as CallExpression[];\n\t\texpression = callExpressions[0];\n\t}\n\n\tif (!expression) {\n\t\treturn {};\n\t}\n\n\tconst { callee, arguments: args } = expression;\n\treturn { callee, args };\n}\n\n/**\n * Return an array of URLs that are passed as arguments to `@dojo/i18n/cldr/load.default` in the specified AST program\n * and with the specified import variable names.\n *\n * @param ast\n * An AST program to parse\n *\n * @param importNames\n * The variables name(s) in the AST program that represent the `@dojo/i18n/cldr/load.default` function.\n * In the overwhelming majority of use cases, there will only be one.\n *\n * @return\n * An array of containing all the string URLs that were passed to the cldr/load function.\n */\nexport const getLoadCallUrls = (function () {\n\t// A map of AST nodes to their parent nodes, used to recursively walk back up the tree when a variable\n\t// is passed to `@dojo/i18n/cldr/load.default`.\n\tconst treeMap = new Map<any, any>();\n\n\t/**\n\t * @private\n\t * Recursively walk the provided AST tree, extracting URL arrays passed to `@dojo/i18n/core/load`.\n\t */\n\tfunction getLoadCallUrls(item: any, importNames: string[], urls: string[] = []): string[] {\n\t\tif (!item || importNames.length === 0) {\n\t\t\treturn urls;\n\t\t}\n\n\t\tif (Array.isArray(item)) {\n\t\t\treturn item.reduce((urls, child: any) => {\n\t\t\t\ttreeMap.set(child, item);\n\t\t\t\treturn getLoadCallUrls(child, importNames, urls);\n\t\t\t}, urls);\n\t\t}\n\t\telse {\n\t\t\t// If the node in question is redefining our `load.default`, ignore the entire node.\n\t\t\tif (isShadowing(item, importNames)) {\n\t\t\t\treturn urls;\n\t\t\t}\n\n\t\t\tif (item.type === 'CallExpression') {\n\t\t\t\tif (item.callee.type === 'MemberExpression' && testMemberExpression(item.callee, importNames)) {\n\t\t\t\t\tconst arg = item.arguments.length > 1 ? item.arguments[1] : item.arguments[0];\n\t\t\t\t\tconst argArray = extractArrayValues(arg);\n\n\t\t\t\t\tif (argArray) {\n\t\t\t\t\t\turls = mergeUnique(urls, argArray);\n\t\t\t\t\t}\n\t\t\t\t\telse if (arg && arg.type === 'Identifier') {\n\t\t\t\t\t\t// walk up the tree to find the first value with the given name.\n\t\t\t\t\t\tconst value = findFirstValue(item, arg.name);\n\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tconst argArray = extractArrayValues(value.init);\n\t\t\t\t\t\t\tif (argArray) {\n\t\t\t\t\t\t\t\turls = mergeUnique(urls, argArray);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst nextItem = getNextItem(item);\n\t\t\ttreeMap.set(nextItem, item);\n\t\t\treturn getLoadCallUrls(nextItem, importNames, urls);\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * Walk back up the AST tree from the specified node, looking for a variable with the provided name.\n\t */\n\tfunction findFirstValue(item: any, name: string): any {\n\t\tlet parent = treeMap.get(item);\n\t\twhile (parent) {\n\t\t\tconst variableDeclaration = getMatchingVariableDeclaration(parent, name);\n\t\t\tif (variableDeclaration) {\n\t\t\t\treturn variableDeclaration;\n\t\t\t}\n\n\t\t\tparent = treeMap.get(parent);\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * Return the first variable declarations whos name matches the provided name.\n\t *\n\t * @param item\n\t * An AST node, or an array of AST nodes, to inspect.\n\t *\n\t * @param name\n\t * A variable name.\n\t *\n\t * @return\n\t * The variable declaration with the specified name if it exists, `undefined` if it does not.\n\t */\n\tfunction getMatchingVariableDeclaration(item: any, name: string): any {\n\t\tif (Array.isArray(item)) {\n\t\t\tfor (let i = 0; i < item.length; i++) {\n\t\t\t\tconst result = getMatchingVariableDeclaration(item[i], name);\n\t\t\t\tif (result) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (item.type === 'VariableDeclaration') {\n\t\t\tconst matching = item.declarations.filter((declaration: any) => declaration.id.name === name);\n\t\t\treturn matching[0];\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * Determine whether the specified member expression represents the `default` value on the\n\t * on an object with at least one of the specified variable names.\n\t *\n\t * For example, if `importNames` is `[ 'loadCldrData' ]`, then a call to `loadCldrData.default` will match.\n\t *\n\t * @param item\n\t * A MemberExpression node\n\t *\n\t * @param importNames\n\t * A list of variable names.\n\t *\n\t * @return\n\t * `true` if the test passes; `false` otherwise.\n\t */\n\tfunction testMemberExpression(item: any, importNames: string[]): boolean {\n\t\tconst { object, property } = item;\n\t\treturn importNames.indexOf(object.name) > -1 && property.name === 'default';\n\t}\n\n\treturn function (program: Program, importNames: string[]): string[] {\n\t\tconst urls = getLoadCallUrls(program, importNames);\n\t\ttreeMap.clear();\n\t\treturn urls;\n\t};\n})();\n\n/**\n * Return an array of variable names for `@dojo/i18n/cldr/load` imports.\n *\n * @param ast\n * An AST program to parse.\n *\n * @return\n * A list of variable names.\n */\nexport function getLoadImports(ast: Program): string[] {\n\treturn ast.body.filter(item => item.type === 'VariableDeclaration')\n\t\t.reduce((a: VariableDeclarator[], b: VariableDeclaration) => {\n\t\t\treturn a.concat(b.declarations);\n\t\t}, [])\n\t\t.filter(((item: VariableDeclarator) => {\n\t\t\tconst expression = item.init as CallExpression;\n\t\t\tconst { callee, args } = getCallExpressionData(expression);\n\t\t\treturn callee && callee.name === 'require' && args && args.length === 1 && /cldr\\/load/.test((<any> args[0]).value);\n\t\t}))\n\t\t.map(item => (<Identifier> item.id).name);\n}\n\n/**\n * Parse an AST program for all URLs passed to `@dojo/i18n/cldr/load`.\n *\n * Note that `@dojo/i18n/cldr/load` must be loaded with `require` for it to be recognized.\n * URLs can be injected as an array either directly to cldr/load function, or via a variable that is defined within\n * the same program. If a variable is used, then its definition MUST be a straightforward array expression:\n * `const cldrUrls = [ ... ]`. More complex operatiions will not be registered (for example:\n * `const supplemental = [ 'likelySubtags' ].map(name => `cldr-data/supplemental/${name}.json`).\n *\n * @param ast\n * An AST program\n *\n * @return\n * An array of any URLs parsed from calls to `@dojo/i18n/cldr/load.default`.\n */\nexport default function getCldrUrls(context: string, ast: Program): string[] {\n\tconst importNames = getLoadImports(ast);\n\tconst urls = getLoadCallUrls(ast, importNames);\n\treturn urls.map((url: string) => {\n\t\treturn isRelative(url) ? path.resolve(getBasePath(context), url) : url;\n\t});\n}\n"]}