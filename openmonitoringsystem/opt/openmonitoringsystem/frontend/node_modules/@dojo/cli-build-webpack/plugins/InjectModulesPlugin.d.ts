import NormalModule = require('webpack/lib/NormalModule');
import NormalModuleFactory = require('webpack/lib/NormalModuleFactory');
import Chunk = require('webpack/lib/Chunk');
import Compiler = require('webpack/lib/Compiler');
import Compilation = require('webpack/lib/Compilation');
import Map from '@dojo/shim/Map';
import '@dojo/shim/Promise';
export interface InjectModulesPluginOptions {
    /**
     * An optional base path for the injected modules. If not provided, defaults to the `resolve.root` option.
     * If `resolve.root` is an array, then the first path is used. If there is no `resolve.root`, then
     * `${process.cwd()}/node_modules/` is used.
     */
    context?: string;
    /**
     * The IDs for modules that should be injected into the build. If an array is provided, then the plugin's
     * `context` is used as the context. An object of contexts to module IDs can also be provided. IDs can be
     * either relative or absolute. If an ID is relative, then it will be resolved relative to the issuer; if
     * absolute, it will be resolved relative to the context.
     */
    moduleIds: ModuleIds;
    /**
     * The regular expression that matches module paths to determine whether the specified module IDs should
     * be injected into the relevant chunk(s).
     */
    resourcePattern: RegExp;
}
export declare type ModuleIds = string[] | {
    [basePath: string]: string[];
};
/**
 * A webpack plugin that injects arbitrary modules into the relevant build chunks if a module matching a specified
 * pattern is included somewhere in the current module hierarchy.
 */
export default class InjectModulesPlugin {
    protected _added: string[];
    protected _modules: Map<string, NormalModule>;
    context?: string;
    moduleIds: ModuleIds;
    resourcePattern: RegExp;
    constructor(options: InjectModulesPluginOptions);
    /**
     * Set up the compiler and compilation event listeners.
     *
     * @param compiler
     * The compiler instance.
     */
    apply(compiler: Compiler): void;
    /**
     * Generate and build the module instances, and then inject them into the current compilation.
     *
     * @param data
     * An array of resolved request data used to generate the module object.
     *
     * @param compilation
     * The current compilation.
     *
     * @return
     * A promise that resolves once all modules have been built.
     */
    createModules(data: NormalModuleFactory.AfterData[], compilation: Compilation): Promise<void[]>;
    injectModuleDependencies(module: NormalModule, chunk: Chunk): void;
    /**
     * Resolve the request data for all modules injected for the specified resource.
     *
     * @param resource
     * The context for the injected modules.
     *
     * @param resolver
     * The resolver function.
     *
     * @return
     * A promise that resolves to the request data for the injected modules.
     */
    resolve(resource: string, resolver: NormalModuleFactory.Resolver): Promise<NormalModuleFactory.AfterData[]>;
}
