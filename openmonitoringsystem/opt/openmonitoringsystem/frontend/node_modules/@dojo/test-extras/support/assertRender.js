(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "@dojo/core/lang", "@dojo/shim/Set", "@dojo/widget-core/d", "./AssertionError", "./compare", "./d"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var lang_1 = require("@dojo/core/lang");
    var Set_1 = require("@dojo/shim/Set");
    var d_1 = require("@dojo/widget-core/d");
    var AssertionError_1 = require("./AssertionError");
    var compare_1 = require("./compare");
    var d_2 = require("./d");
    var RENDER_FAIL_MESSAGE = 'Render unexpected';
    /**
     * Return a string that provides diagnostic information when comparing DNodes where one should be an array
     * @param actual The actual DNode
     * @param expected The expected DNode
     */
    function getArrayPreamble(actual, expected) {
        return Array.isArray(actual) ?
            "Expected \"" + getTypeOf(expected) + "\" but got an array" :
            "Expected an array but got \"" + getTypeOf(actual) + "\"";
    }
    /**
     * An internal function that returns a string that contains an array of child indexes which related to the message
     * @param childIndex The index of the child to add to the message
     * @param message The message, if any to prepend the child to
     */
    function getChildMessage(childIndex, message) {
        if (message === void 0) { message = ''; }
        var lastIndex = message.lastIndexOf(']');
        if (lastIndex === -1) {
            return "[" + childIndex + "] " + message;
        }
        else {
            return message.slice(0, lastIndex + 1) + ("[" + childIndex + "]") + message.slice(lastIndex + 1);
        }
    }
    /**
     * Return a string that provides diagnostic information when two DNodes being compared are mismatched
     * @param actual The actual DNode
     * @param expected The expected DNode
     */
    function getMismatchPreamble(actual, expected) {
        return "DNode type mismatch, expected \"" + getTypeOf(expected) + "\" actual \"" + getTypeOf(actual) + "\"";
    }
    /**
     * Return a string that represents the type of the value, including null as a seperate type.
     * @param value The value to get the type of
     */
    function getTypeOf(value) {
        return value === null ? 'null' : typeof value;
    }
    /**
     * Internal function that throws an AssertionError
     * @param actual actual value
     * @param expected expected value
     * @param prolog a message that provides the specific assertion issue
     * @param message any message to be part of the error
     */
    function throwAssertionError(actual, expected, prolog, message) {
        throw new AssertionError_1.default(RENDER_FAIL_MESSAGE + ": " + prolog + (message ? ": " + message : ''), {
            actual: actual,
            expected: expected,
            showDiff: true
        }, assertRender);
    }
    /**
     * Options used to configure diff to correctly compare `DNode`s
     */
    var defaultDiffOptions = {
        allowFunctionValues: true,
        ignoreProperties: ['bind']
    };
    function assertRender(actual, expected, options, message) {
        if (typeof options === 'string') {
            message = options;
            options = undefined;
        }
        var _a = (options || {}), _b = _a.isHNode, localIsHNode = _b === void 0 ? d_1.isHNode : _b, _c = _a.isWNode, localIsWNode = _c === void 0 ? d_1.isWNode : _c, passedDiffOptions = tslib_1.__rest(_a, ["isHNode", "isWNode"]);
        var diffOptions = lang_1.assign({}, defaultDiffOptions, passedDiffOptions);
        function assertChildren(actual, expected) {
            if (actual && expected) {
                if (actual.length !== expected.length) {
                    throwAssertionError(actual, expected, "Children's length mismatch", message);
                }
                actual.forEach(function (actualChild, index) {
                    assertRender(actualChild, expected[index], (options || {}), getChildMessage(index, message));
                });
            }
            else {
                if (actual || expected) {
                    throwAssertionError(actual, expected, actual ? 'Unxpected children' : 'Expected children', message);
                }
            }
        }
        if (Array.isArray(actual) && Array.isArray(expected)) {
            assertChildren(actual, expected);
        }
        else if (Array.isArray(actual) || Array.isArray(expected)) {
            throwAssertionError(actual, expected, getArrayPreamble(actual, expected), message);
        }
        else if ((localIsHNode(actual) && localIsHNode(expected)) || (localIsWNode(actual) && localIsWNode(expected))) {
            if (localIsHNode(actual) && localIsHNode(expected)) {
                if (actual.tag !== expected.tag) {
                    /* The tags do not match */
                    throwAssertionError(actual.tag, expected.tag, "Tags do not match", message);
                }
            }
            else if (localIsWNode(actual) && localIsWNode(expected)) {
                if (actual.widgetConstructor !== expected.widgetConstructor) {
                    /* The WNode does not share the same constructor */
                    throwAssertionError(actual.widgetConstructor, expected.widgetConstructor, "WNodes do not share constructor", message);
                }
            }
            /* Inject a custom comparator for class names */
            var expectedClasses_1 = expected.properties && expected.properties.classes;
            if (expectedClasses_1 && !compare_1.isCustomDiff(expectedClasses_1)) {
                expected.properties.classes = d_2.compareProperty(function (value) {
                    var expectedValue = typeof expectedClasses_1 === 'string' ? [expectedClasses_1] : expectedClasses_1;
                    value = (typeof value === 'string' ? [value] : value) || [];
                    var expectedSet = new Set_1.default(expectedValue.filter(function (expectedClass) { return Boolean(expectedClass); }));
                    var actualSet = new Set_1.default(value.filter(function (actualClass) { return Boolean(actualClass); }));
                    if (expectedSet.size !== actualSet.size) {
                        return false;
                    }
                    var allMatch = true;
                    actualSet.forEach(function (actualClass) {
                        allMatch = allMatch && expectedSet.has(actualClass);
                    });
                    return allMatch;
                });
            }
            var delta = compare_1.diff(actual.properties, expected.properties, diffOptions);
            if (delta.length) {
                /* The properties do not match */
                var _d = compare_1.getComparableObjects(actual.properties, expected.properties, diffOptions), comparableA = _d.comparableA, comparableB = _d.comparableB;
                throwAssertionError(comparableA, comparableB, "Properties do not match", message);
            }
            /* We need to assert the children match */
            assertChildren(actual.children, expected.children);
        }
        else if (typeof actual === 'string' && typeof expected === 'string') {
            /* Both DNodes are strings */
            if (actual !== expected) {
                /* The strings do not match */
                throwAssertionError(actual, expected, "Unexpected string values", message);
            }
        }
        else if (d_1.isHNode(actual) && typeof expected === 'string') {
            // when doing an expected render on already rendered nodes, strings are converted to _shell_ HNodes
            // so we want to compare to those instead
            if (actual.text !== expected) {
                throwAssertionError(actual.text, expected, "Expected text differs from rendered text", message);
            }
        }
        else if (!(actual === null && expected === null)) {
            /* There is a mismatch between the types of DNodes */
            throwAssertionError(actual, expected, getMismatchPreamble(actual, expected), message);
        }
    }
    exports.default = assertRender;
});
//# sourceMappingURL=assertRender.js.map