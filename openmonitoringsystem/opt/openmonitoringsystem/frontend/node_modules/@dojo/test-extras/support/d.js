(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/lang", "@dojo/widget-core/d", "./AssertionError", "./compare"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lang_1 = require("@dojo/core/lang");
    var d_1 = require("@dojo/widget-core/d");
    var AssertionError_1 = require("./AssertionError");
    var compare_1 = require("./compare");
    function assignChildPropertiesByKeyOrIndex(target, keyOrIndex, properties, byKey) {
        var node = findByKeyOrIndex(target, keyOrIndex, byKey).found;
        if (!node || !(d_1.isWNode(node) || d_1.isHNode(node))) {
            var keyOrIndexString = typeof keyOrIndex === 'object' ? JSON.stringify(keyOrIndex) : keyOrIndex;
            throw new TypeError(((byKey || typeof keyOrIndex === 'object') ? 'Key' : 'Index') + " of \"" + keyOrIndexString + "\" is not resolving to a valid target");
        }
        assignProperties(node, properties);
        return target;
    }
    function assignChildProperties(target, index, properties) {
        return assignChildPropertiesByKeyOrIndex(target, index, properties);
    }
    exports.assignChildProperties = assignChildProperties;
    function assignChildPropertiesByKey(target, key, properties) {
        return assignChildPropertiesByKeyOrIndex(target, key, properties, true);
    }
    exports.assignChildPropertiesByKey = assignChildPropertiesByKey;
    function assignProperties(target, properties) {
        lang_1.assign(target.properties, properties);
        return target;
    }
    exports.assignProperties = assignProperties;
    /**
     * Creates a function which, when placed in an expected render, will call the `callback`.  If the `callback` returns `true`, the value
     * of the property is considered equal, otherwise it is considered not equal and the expected render will fail.
     * @param callback A function that is invoked when comparing the property value
     */
    function compareProperty(callback) {
        function differ(value, name, parent) {
            if (!callback(value, name, parent)) {
                throw new AssertionError_1.default("The value of property \"" + name + "\" is unexpected.", {}, differ);
            }
        }
        return new compare_1.CustomDiff(differ);
    }
    exports.compareProperty = compareProperty;
    function replaceChildByKeyOrIndex(target, indexOrKey, replacement, byKey) {
        if (byKey === void 0) { byKey = false; }
        if (!target.children) {
            throw new TypeError('Target does not have children.');
        }
        var _a = findByKeyOrIndex(target, indexOrKey, byKey), parent = _a.parent, index = _a.index;
        if (!parent || typeof index === 'undefined' || !parent.children) {
            if (byKey || typeof indexOrKey === 'object') {
                throw new TypeError("Key of \"" + (typeof indexOrKey === 'object' ? JSON.stringify(indexOrKey) : indexOrKey) + "\" is not resolving to a valid target");
            }
            else {
                throw new TypeError("Index of \"" + indexOrKey + "\" is not resolving to a valid target");
            }
        }
        else {
            parent.children[index] = replacement;
        }
        return target;
    }
    /**
     * Finds the child of the target that has the provided key, and replaces it with the provided node.
     *
     * *NOTE:* The replacement modifies the passed `target` and does not return a new instance of the `DNode`.
     * @param target The DNode to replace a child element on
     * @param key The key of the node to replace
     * @param replacement The DNode that replaces the found node
     * @returns {WNode | HNode}
     */
    function replaceChildByKey(target, key, replacement) {
        return replaceChildByKeyOrIndex(target, key, replacement, true);
    }
    exports.replaceChildByKey = replaceChildByKey;
    /**
     * Replace a child of DNode.
     *
     * *NOTE:* The replacement modifies the passed `target` and does not return a new instance of the `DNode`.
     * @param target The DNode to replace a child element on
     * @param index A number of the index of a child, or a string with comma separated indexes that would navigate
     * @param replacement The DNode to be replaced
     */
    function replaceChild(target, index, replacement) {
        return replaceChildByKeyOrIndex(target, index, replacement);
    }
    exports.replaceChild = replaceChild;
    function isNode(value) {
        return value && typeof value === 'object' && value !== null;
    }
    function findByKeyOrIndex(target, keyOrIndex, byKey) {
        if (byKey === void 0) { byKey = false; }
        if (byKey || typeof keyOrIndex === 'object') {
            return findByKey(target, keyOrIndex);
        }
        else {
            return findByIndex(target, keyOrIndex);
        }
    }
    function findByKey(target, key, parent, index) {
        if (target.properties.key === key) {
            return { parent: parent, found: target, index: index };
        }
        if (!target.children) {
            return {};
        }
        var nodeInfo;
        target.children
            .forEach(function (child, index) {
            if (isNode(child)) {
                if (nodeInfo && nodeInfo.found) {
                    if (findByKey(child, key, target, index).found) {
                        console.warn("Duplicate key of \"" + (typeof key === 'object' ? JSON.stringify(key) : key) + "\" found.");
                    }
                }
                else {
                    nodeInfo = findByKey(child, key, target, index);
                }
            }
        });
        return nodeInfo || {};
    }
    function findByIndex(target, index) {
        if (typeof index === 'number') {
            return target.children ? { parent: target, found: target.children[index], index: index } : {};
        }
        var indexes = index.split(',').map(Number);
        var lastIndex = indexes.pop();
        var resolvedTarget = indexes.reduce(function (target, idx) {
            if (!(d_1.isWNode(target) || d_1.isHNode(target)) || !target.children) {
                return target;
            }
            return target.children[idx];
        }, target);
        if (!(d_1.isWNode(resolvedTarget) || d_1.isHNode(resolvedTarget)) || !resolvedTarget.children) {
            return {};
        }
        return { parent: resolvedTarget, found: resolvedTarget.children[lastIndex], index: lastIndex };
    }
    /**
     * Find a virtual DOM node (`WNode` or `HNode`) based on it having a matching `key` property.
     *
     * The function returns `undefined` if no node was found, otherwise it returns the node.  *NOTE* it will return the first node
     * matching the supplied `key`, but will `console.warn` if more than one node was found.
     */
    function findKey(target, key) {
        var found = findByKey(target, key).found;
        return found;
    }
    exports.findKey = findKey;
    /**
     * Return a `DNode` that is identified by supplied index
     * @param target The target `WNode` or `HNode` to resolve the index for
     * @param index A number or a string indicating the child index
     */
    function findIndex(target, index) {
        var found = findByIndex(target, index).found;
        return found;
    }
    exports.findIndex = findIndex;
    function replaceChildPropertiesByKeyOrIndex(target, indexOrKey, properties, byKey) {
        if (byKey === void 0) { byKey = false; }
        var found = findByKeyOrIndex(target, indexOrKey, byKey).found;
        if (!found || !(d_1.isWNode(found) || d_1.isHNode(found))) {
            if (byKey || typeof indexOrKey === 'object') {
                throw new TypeError("Key of \"" + (typeof indexOrKey === 'object' ? JSON.stringify(indexOrKey) : indexOrKey) + "\" is not resolving to a valid target");
            }
            else {
                throw new TypeError("Index of \"" + indexOrKey + "\" is not resolving to a valid target");
            }
        }
        replaceProperties(found, properties);
        return target;
    }
    function replaceChildProperties(target, index, properties) {
        return replaceChildPropertiesByKeyOrIndex(target, index, properties);
    }
    exports.replaceChildProperties = replaceChildProperties;
    function replaceChildPropertiesByKey(target, key, properties) {
        return replaceChildPropertiesByKeyOrIndex(target, key, properties, true);
    }
    exports.replaceChildPropertiesByKey = replaceChildPropertiesByKey;
    function replaceProperties(target, properties) {
        target.properties = properties;
        return target;
    }
    exports.replaceProperties = replaceProperties;
});
//# sourceMappingURL=d.js.map