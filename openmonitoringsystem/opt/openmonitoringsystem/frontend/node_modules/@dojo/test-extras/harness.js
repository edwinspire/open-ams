(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "pepjs", "@dojo/core/Evented", "@dojo/core/lang", "@dojo/shim/object", "@dojo/shim/WeakMap", "@dojo/widget-core/d", "@dojo/widget-core/WidgetBase", "@dojo/widget-core/decorators/afterRender", "@dojo/widget-core/mixins/Projector", "./support/assertRender", "./support/callListener", "./support/sendEvent"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    require("pepjs");
    var Evented_1 = require("@dojo/core/Evented");
    var lang_1 = require("@dojo/core/lang");
    var object_1 = require("@dojo/shim/object");
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var d_1 = require("@dojo/widget-core/d");
    var WidgetBase_1 = require("@dojo/widget-core/WidgetBase");
    var afterRender_1 = require("@dojo/widget-core/decorators/afterRender");
    var Projector_1 = require("@dojo/widget-core/mixins/Projector");
    var assertRender_1 = require("./support/assertRender");
    var callListener_1 = require("./support/callListener");
    var sendEvent_1 = require("./support/sendEvent");
    /* tslint:disable:variable-name */
    var ROOT_CUSTOM_ELEMENT_NAME = 'test--harness';
    var WIDGET_STUB_CUSTOM_ELEMENT = 'test--widget-stub';
    var WIDGET_STUB_NAME_PROPERTY = 'data--widget-name';
    var harnessId = 0;
    /**
     * An internal function which finds a DNode base on a `key`
     * @param target the root DNode to search
     * @param key the key to match
     */
    function findDNodeByKey(target, key) {
        if (target && typeof target === 'object') {
            if (target && typeof target === 'object' && target.properties && target.properties.key === key) {
                return target;
            }
            var found_1;
            if (target.children) {
                target.children
                    .forEach(function (child) {
                    if (found_1) {
                        if (findDNodeByKey(child, key)) {
                            console.warn("Duplicate key of \"" + key + "\" found.");
                        }
                    }
                    else {
                        found_1 = findDNodeByKey(child, key);
                    }
                });
            }
            return found_1;
        }
    }
    /**
     * Decorate a `DNode` where any `WNode`s are replaced with stubbed widgets
     * @param target The `DNode` to decorate with stubbed widgets
     */
    function stubRender(target) {
        d_1.decorate(target, function (dNode) {
            var widgetConstructor = dNode.widgetConstructor, properties = dNode.properties;
            dNode.widgetConstructor = StubWidget;
            properties._stubTag = WIDGET_STUB_CUSTOM_ELEMENT;
            properties._widgetName = typeof widgetConstructor === 'string'
                ? widgetConstructor
                : widgetConstructor.name || '<Anonymous>';
        }, function (dNode) { return d_1.isWNode(dNode); });
        return target;
    }
    var StubWidget = (function (_super) {
        tslib_1.__extends(StubWidget, _super);
        function StubWidget() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StubWidget.prototype.render = function () {
            var _a = this.properties, tag = _a._stubTag, widgetName = _a._widgetName;
            return d_1.v(tag, (_b = {}, _b[WIDGET_STUB_NAME_PROPERTY] = widgetName, _b), this.children);
            var _b;
        };
        return StubWidget;
    }(WidgetBase_1.default));
    /**
     * A mixin that adds a spy to a widget
     * @param base The base class to add the render spy to
     * @param target An object with a property named `lastRender` which will be set to the result of the `render()` method
     */
    function SpyWidgetMixin(base, target) {
        var SpyRender = (function (_super) {
            tslib_1.__extends(SpyRender, _super);
            function SpyRender() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SpyRender.prototype.spyRender = function (result) {
                target.actualRender(result);
                return stubRender(result);
            };
            SpyRender.prototype.meta = function (provider) {
                return target.decorateMeta(_super.prototype.meta.call(this, provider));
            };
            tslib_1.__decorate([
                afterRender_1.afterRender()
            ], SpyRender.prototype, "spyRender", null);
            return SpyRender;
        }(base));
        return SpyRender;
    }
    /**
     * A private class that is used to actually render the widget and keep track of the last render by
     * the harnessed widget.
     */
    var WidgetHarness = (function (_super) {
        tslib_1.__extends(WidgetHarness, _super);
        function WidgetHarness(widgetConstructor, metaData) {
            var _this = _super.call(this) || this;
            _this._id = ROOT_CUSTOM_ELEMENT_NAME + '-' + (++harnessId);
            _this.didRender = false;
            _this.renderCount = 0;
            _this._widgetConstructor = SpyWidgetMixin(widgetConstructor, _this);
            _this._metaData = metaData;
            return _this;
        }
        /**
         * Called by a harnessed widget's render spy, allowing potential assertion of the render
         * @param actual The render, just after `afterRender`
         */
        WidgetHarness.prototype.actualRender = function (actual) {
            this.lastRender = actual;
            this.didRender = true;
            this.renderCount++;
            var _a = this, message = _a.assertionMessage, expected = _a.expectedRender;
            if (expected) {
                this.expectedRender = undefined;
                this.assertionMessage = undefined;
                assertRender_1.default(actual, expected, message);
            }
        };
        /**
         * _Mixin_ the methods that are provided as part of the mock.
         * @param provider The instance of the meta provider associated with the harnessed widget
         */
        WidgetHarness.prototype.decorateMeta = function (provider) {
            var data = this._metaData.get(provider.constructor);
            return data ? object_1.assign(provider, data.mocks) : provider;
        };
        WidgetHarness.prototype.invalidate = function () {
            _super.prototype.invalidate.call(this);
        };
        /**
         * Wrap the widget in a custom element
         */
        WidgetHarness.prototype.render = function () {
            var _a = this, id = _a._id, _widgetConstructor = _a._widgetConstructor, children = _a.children, properties = _a.properties;
            return d_1.v(ROOT_CUSTOM_ELEMENT_NAME, { id: id }, [d_1.w(_widgetConstructor, properties, children)]);
        };
        return WidgetHarness;
    }(WidgetBase_1.default));
    var ProjectorWidgetHarness = Projector_1.ProjectorMixin(WidgetHarness);
    /**
     * Harness a widget constructor, providing an API to interact with the widget for testing purposes.
     */
    var Harness = (function (_super) {
        tslib_1.__extends(Harness, _super);
        function Harness(widgetConstructor, root) {
            var _this = _super.call(this, {}) || this;
            _this._metaMap = new WeakMap_1.default();
            /**
             * Provides a reference to a function that can be used when creating an expected render value
             */
            _this.listener = function () { return true; };
            var widgetHarness = _this._widgetHarness = new ProjectorWidgetHarness(widgetConstructor, _this._metaMap);
            // we want to control when the render gets scheduled, so we will hijack the projects one
            _this._scheduleRender = widgetHarness.scheduleRender.bind(widgetHarness);
            widgetHarness.scheduleRender = function () { };
            _this.own(widgetHarness);
            _this._root = root;
            return _this;
        }
        Harness.prototype._invalidate = function () {
            if (this._properties) {
                this._widgetHarness.setProperties(this._properties);
                this._properties = undefined;
            }
            if (this._children) {
                this._widgetHarness.setChildren(this._children);
                this._children = undefined;
            }
            if (!this._projectorHandle) {
                this._widgetHarness.async = false;
                this._projectorHandle = this._widgetHarness.append(this._root);
            }
            this._scheduleRender();
        };
        /**
         * Call a listener on a target node of the virtual DOM.
         * @param method The method to call on the target node
         * @param options A map of options that effect the behavior of `callListener`
         */
        Harness.prototype.callListener = function (method, options) {
            var render = this.getRender();
            if (typeof render !== 'object' || render === null) {
                throw new TypeError('Widget is not rendering an HNode or WNode');
            }
            callListener_1.default(render, method, options);
        };
        /**
         * Assert an expected virtual DOM (`DNode`) against what is actually being rendered.  Will throw if the expected does
         * not match the actual.
         * @param expected The expected render (`DNode`)
         * @param message Any message to be part of an error that gets thrown if the actual and expected do not match
         */
        Harness.prototype.expectRender = function (expected, message) {
            this._widgetHarness.expectedRender = expected;
            this._widgetHarness.assertionMessage = message;
            this._widgetHarness.didRender = false;
            this._invalidate();
            if (!this._widgetHarness.didRender) {
                throw new Error('An expected render did not occur.');
            }
            return this;
        };
        /**
         * Get the root element of the harnessed widget.  This will refresh the render.
         */
        Harness.prototype.getDom = function () {
            if (!this._projectorHandle) {
                this._invalidate();
            }
            if (!(this._widgetHarness.lastRender) || !this._widgetHarness.lastRender.domNode) {
                throw new Error('No root node has been rendered');
            }
            return this._widgetHarness.lastRender.domNode;
        };
        /**
         * Provide a mock for a meta provider that will be used instead of source provider
         * @param provider The meta provider to mock
         * @param mocks A set of methods/properties to mock on the provider
         */
        Harness.prototype.mockMeta = function (provider, mocks) {
            var _metaMap = this._metaMap;
            if (!_metaMap.has(provider)) {
                _metaMap.set(provider, {
                    handle: lang_1.createHandle(function () {
                        _metaMap.delete(provider);
                    }),
                    // TODO: no need to coerce in 2.5.2
                    mocks: mocks
                });
            }
            else {
                // TODO: no need to coerce in 2.5.2
                _metaMap.get(provider).mocks = mocks;
            }
            return _metaMap.get(provider).handle;
        };
        /**
         * Refresh the render and return the last render's root `DNode`.
         */
        Harness.prototype.getRender = function () {
            this._invalidate();
            return this._widgetHarness.lastRender;
        };
        /**
         * Dispatch an event to the root DOM element of the rendered harnessed widget.  You can use the options to change the
         * event class, provide additional event properties, or select a different `target`.
         *
         * By default, the event class is `CustomEvent` and `bubbles` and `cancelable` are both `true` on events dispatched by
         * the harness.
         * @param type The type of event (e.g. `click` or `mousedown`)
         * @param options Options which can modify the event sent, like using a different EventClass or selecting a different
         *                        node to target, or provide the event initialisation properties
         */
        Harness.prototype.sendEvent = function (type, options) {
            if (options === void 0) { options = {}; }
            var _a = options.target, target = _a === void 0 ? this.getDom() : _a, key = options.key, sendOptions = tslib_1.__rest(options, ["target", "key"]);
            if (key) {
                var dnode = findDNodeByKey(this._widgetHarness.lastRender, key);
                if (d_1.isHNode(dnode)) {
                    target = dnode.domNode;
                }
                else {
                    throw new Error("Could not find key of \"" + key + "\" to sendEvent");
                }
            }
            sendEvent_1.default(target, type, sendOptions);
            return this;
        };
        /**
         * Set the children that will be used when rendering the harnessed widget
         * @param children The children to be set on the harnessed widget
         */
        Harness.prototype.setChildren = function (children) {
            this._children = children;
            return this;
        };
        /**
         * Set the properties that will be passed to the harnessed widget on the next render
         * @param properties The properties to set
         */
        Harness.prototype.setProperties = function (properties) {
            this._properties = properties;
            return this;
        };
        return Harness;
    }(Evented_1.default));
    exports.Harness = Harness;
    /**
     * Harness a widget class for testing purposes, returning an API to interact with the harness widget class.
     * @param widgetConstructor The constructor function/class of widget that should be harnessed.
     * @param root The root where the harness should append itself to the DOM.  Defaults to `document.body`
     */
    function harness(widgetConstructor, root) {
        return new Harness(widgetConstructor, root);
    }
    exports.default = harness;
});
//# sourceMappingURL=harness.js.map