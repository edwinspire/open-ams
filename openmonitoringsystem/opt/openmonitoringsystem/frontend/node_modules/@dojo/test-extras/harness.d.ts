import 'pepjs';
import Evented from '@dojo/core/Evented';
import { Handle } from '@dojo/interfaces/core';
import { Constructor, DNode, WidgetMetaBase, WidgetProperties } from '@dojo/widget-core/interfaces';
import WidgetBase from '@dojo/widget-core/WidgetBase';
import { CallListenerOptions } from './support/callListener';
import { SendEventOptions } from './support/sendEvent';
export interface HarnessSendEventOptions<I extends EventInit> extends SendEventOptions<I> {
    /**
     * Find the target node by `key`
     */
    key?: any;
    /**
     * Provide an alternative target instead of the root DOM node
     */
    target?: Element;
}
/**
 * Provides a run time context for methods of a meta mock.
 */
export declare type MetaMockContext<T extends WidgetMetaBase = WidgetMetaBase> = T & {
    /**
     * Retrieve a reference to a node that is rendered in the DOM based on its key
     */
    getNode(key: string | number): HTMLElement | undefined;
    /**
     * Invalidate the widget.
     */
    invalidate(): void;
};
/**
 * Harness a widget constructor, providing an API to interact with the widget for testing purposes.
 */
export declare class Harness<W extends WidgetBase<WidgetProperties>> extends Evented {
    private _children;
    private _metaMap;
    private _projectorHandle;
    private _properties;
    private _root;
    private _scheduleRender;
    private _widgetHarness;
    private _invalidate();
    constructor(widgetConstructor: Constructor<W>, root?: HTMLElement);
    /**
     * Provides a reference to a function that can be used when creating an expected render value
     */
    listener: () => boolean;
    /**
     * Call a listener on a target node of the virtual DOM.
     * @param method The method to call on the target node
     * @param options A map of options that effect the behavior of `callListener`
     */
    callListener(method: string, options?: CallListenerOptions): void;
    /**
     * Assert an expected virtual DOM (`DNode`) against what is actually being rendered.  Will throw if the expected does
     * not match the actual.
     * @param expected The expected render (`DNode`)
     * @param message Any message to be part of an error that gets thrown if the actual and expected do not match
     */
    expectRender(expected: DNode | DNode[], message?: string): this;
    /**
     * Get the root element of the harnessed widget.  This will refresh the render.
     */
    getDom(): HTMLElement;
    /**
     * Provide a mock for a meta provider that will be used instead of source provider
     * @param provider The meta provider to mock
     * @param mocks A set of methods/properties to mock on the provider
     */
    mockMeta<T extends WidgetMetaBase>(provider: Constructor<T>, mocks: Partial<T>): Handle;
    /**
     * Refresh the render and return the last render's root `DNode`.
     */
    getRender(): DNode;
    /**
     * Dispatch an event to the root DOM element of the rendered harnessed widget.  You can use the options to change the
     * event class, provide additional event properties, or select a different `target`.
     *
     * By default, the event class is `CustomEvent` and `bubbles` and `cancelable` are both `true` on events dispatched by
     * the harness.
     * @param type The type of event (e.g. `click` or `mousedown`)
     * @param options Options which can modify the event sent, like using a different EventClass or selecting a different
     *                        node to target, or provide the event initialisation properties
     */
    sendEvent<I extends EventInit>(type: string, options?: HarnessSendEventOptions<I>): this;
    /**
     * Set the children that will be used when rendering the harnessed widget
     * @param children The children to be set on the harnessed widget
     */
    setChildren(children: W['children']): this;
    /**
     * Set the properties that will be passed to the harnessed widget on the next render
     * @param properties The properties to set
     */
    setProperties(properties: W['properties']): this;
}
/**
 * Harness a widget class for testing purposes, returning an API to interact with the harness widget class.
 * @param widgetConstructor The constructor function/class of widget that should be harnessed.
 * @param root The root where the harness should append itself to the DOM.  Defaults to `document.body`
 */
export default function harness<W extends WidgetBase<WidgetProperties>>(widgetConstructor: Constructor<W>, root?: HTMLElement): Harness<W>;
