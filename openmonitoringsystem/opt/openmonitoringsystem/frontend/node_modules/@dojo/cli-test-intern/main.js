(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "chalk", "path", "./runTests", "./javaCheck"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const chalk_1 = require("chalk");
    const path = require("path");
    const runTests_1 = require("./runTests");
    const javaCheck_1 = require("./javaCheck");
    const pkgDir = require('pkg-dir');
    const CLI_BUILD_PACKAGE = '@dojo/cli-build-webpack';
    function buildNpmDependencies() {
        try {
            const packagePath = pkgDir.sync(__dirname);
            const packageJsonFilePath = path.join(packagePath, 'package.json');
            const packageJson = require(packageJsonFilePath);
            return packageJson.dependencies;
        }
        catch (e) {
            throw new Error('Failed reading dependencies from package.json - ' + e.message);
        }
    }
    function transformTestArgs(args) {
        let nodeUnit = true;
        let remoteUnit = false;
        let remoteFunctional = false;
        if (args.all) {
            nodeUnit = remoteUnit = remoteFunctional = true;
        }
        if (args.unit) {
            remoteUnit = true;
        }
        if (args.functional) {
            nodeUnit = remoteUnit = false;
            remoteFunctional = true;
        }
        return {
            childConfig: args.config,
            internConfig: args.internConfig,
            reporters: args.reporters,
            userName: args.userName,
            secret: args.secret,
            testingKey: args.testingKey,
            verbose: args.verbose,
            coverage: args.coverage,
            filter: args.filter,
            nodeUnit,
            remoteUnit,
            remoteFunctional
        };
    }
    function printBrowserLink(args) {
        const browserArgs = [];
        if (args.filter) {
            browserArgs.push('grep=' + encodeURIComponent(args.filter));
        }
        console.log('\n If the project directory is hosted on a local server, unit tests can also be run in browser by navigating to ' + chalk_1.underline(`http://localhost:<port>/node_modules/intern/?config=node_modules/@dojo/cli-test-intern/intern/intern.json${browserArgs.length ? `&${browserArgs.join('&')}` : ''}`));
    }
    const command = {
        description: 'this command will implicitly build your application and then run tests against that build',
        register(options) {
            options('a', {
                alias: 'all',
                describe: 'Runs unit tests and functional tests. Unit tests are run via node and the local tunnel. Functional tests are run via the local tunnel',
                default: false
            });
            options('c', {
                alias: 'config',
                describe: `Specifies what configuration to test with: 'local'(default), 'browserstack', 'testingbot', or 'saucelabs'.`,
                type: 'string'
            });
            options('cov', {
                alias: 'coverage',
                describe: `If specified, additional coverage reports will be written.  The will be output to the path specified in argument '-o'/'--output'.`
            });
            options('f', {
                alias: 'functional',
                describe: 'Runs only functional tests. Tests are run via the local tunnel',
                default: false
            });
            options('k', {
                alias: 'testingKey',
                describe: 'API key for testingbot or accesskey for saucelabs or browserstack',
                type: 'string'
            });
            options('usr', {
                alias: 'userName',
                describe: 'User name for testing platform',
                type: 'string'
            });
            options('o', {
                alias: 'output',
                describe: `The path to output any test output to (e.g. coverage information). Defaults to './output/tests'`,
                type: 'string',
                default: './output/tests'
            });
            options('r', {
                alias: 'reporters',
                describe: 'Comma separated list of reporters to use, defaults to Console',
                type: 'string'
            });
            options('s', {
                alias: 'secret',
                describe: 'API secret for testingbot',
                type: 'string'
            });
            options('u', {
                alias: 'unit',
                describe: 'Runs unit tests via node and the local tunnel',
                default: false
            });
            options('v', {
                alias: 'verbose',
                describe: 'Produce diagnostic messages to the console.',
                default: false
            });
            options('n', {
                alias: 'node',
                describe: 'Run unit tests via node',
                type: 'boolean',
                default: true
            });
            options('filter', {
                describe: 'Run only tests whose IDs match a regular expression',
                type: 'string'
            });
        },
        run(helper, args) {
            function unhandledRejection(reason) {
                console.log('Unhandled Promise Rejection: ');
                console.log(reason);
            }
            process.on('unhandledRejection', unhandledRejection);
            return javaCheck_1.default(args).then((javaCheckPassed) => {
                if (javaCheckPassed) {
                    return new Promise((resolve, reject) => {
                        if (!helper.command.exists('build')) {
                            reject(Error(`Required command: 'build', does not exist. Have you run 'npm install ${CLI_BUILD_PACKAGE}'?`));
                        }
                        try {
                            const projectName = require(path.join(process.cwd(), './package.json')).name;
                            console.log('\n' + chalk_1.underline(`building "${projectName}"...`));
                        }
                        catch (e) {
                            console.log('\n' + chalk_1.underline(`building project...`));
                        }
                        const result = helper.command.run('build', '', { withTests: true, disableLazyWidgetDetection: true });
                        result.then(() => {
                            runTests_1.default(transformTestArgs(args))
                                .then(() => {
                                process.removeListener('unhandledRejection', unhandledRejection);
                            })
                                .then(() => {
                                printBrowserLink(args);
                            }, (err) => {
                                printBrowserLink(args);
                                throw err;
                            })
                                .then(resolve, reject);
                        }, reject);
                    });
                }
                else {
                    return Promise.reject(Error(chalk_1.underline('Error! Java VM could not be found.') +
                        '\nA Java VM needs to be installed and available from the command line to allow the ' +
                        chalk_1.underline('dojo test') + ' command to run tests in a browser locally or remotely.'));
                }
            });
        },
        eject() {
            return {
                npm: {
                    devDependencies: Object.assign({}, buildNpmDependencies())
                },
                copy: {
                    path: __dirname + '/intern',
                    files: [
                        './intern.json'
                    ]
                }
            };
        }
    };
    exports.default = command;
});
//# sourceMappingURL=main.js.map