"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var chalk_1 = require("chalk");
var path = require("path");
var fs_extra_1 = require("fs-extra");
var dirname_1 = require("./dirname");
var cs = require('cross-spawn');
var pkgDir = require('pkg-dir');
var packagePath = pkgDir.sync(dirname_1.default);
var logger = console.log;
var reporterDir = 'output/coverage';
var reporterConfigurations = {
    benchmark: {
        directory: reporterDir + "/benchmark",
        filename: 'coverage.xml'
    },
    cobertura: {
        directory: reporterDir + "/cobertura",
        filename: 'coverage.xml'
    },
    htmlcoverage: {
        directory: reporterDir + "/html"
    },
    jsoncoverage: {
        directory: reporterDir + "/json"
    },
    junit: {
        filename: reporterDir + "/junit/coverage.xml"
    },
    lcov: {
        directory: reporterDir + "/lcov",
        filename: 'coverage.lcov'
    },
    pretty: 'pretty',
    runner: 'runner',
    simple: 'simple',
    teamcity: 'teamcity'
};
function parseArguments(testArgs) {
    var nodeUnit = testArgs.nodeUnit, remoteUnit = testArgs.remoteUnit, remoteFunctional = testArgs.remoteFunctional, childConfig = testArgs.childConfig, internConfig = testArgs.internConfig, externals = testArgs.externals, reporters = testArgs.reporters, testingKey = testArgs.testingKey, userName = testArgs.userName, filter = testArgs.filter;
    var configArg = childConfig ? "@" + childConfig : '';
    var configPath = path.relative(process.cwd(), path.join(packagePath, 'intern', internConfig + configArg));
    var args = ["config=" + configPath];
    // by default, in the intern config, all tests are run. we need to
    // disable tests that we dont want to run
    if (!remoteUnit && !nodeUnit) {
        args.push('suites=');
    }
    if (externals) {
        if (!childConfig) {
            throw new Error('Dojo JIT does not currently support externals, ' +
                'please specify a config option to run tests against the built code');
        }
        args.push("loader=" + JSON.stringify({
            script: 'node_modules/@dojo/cli-test-intern/loaders/externals.js',
            options: externals
        }));
    }
    if (!remoteUnit && !remoteFunctional) {
        args.push('environments=');
    }
    else if (!remoteFunctional) {
        args.push('functionalSuites=');
    }
    if (filter) {
        args.push('grep=' + filter);
    }
    if (reporters) {
        var includeRunner_1 = true;
        var formattedReporters = reporters
            .split(',')
            .filter(function (reporter) { return reporterConfigurations[reporter.toLowerCase()] !== undefined; })
            .map(function (reporter) {
            var config = reporterConfigurations[reporter.toLowerCase()];
            if (typeof config === 'string') {
                includeRunner_1 = false;
                return "reporters=" + config;
            }
            var reporterConfig = "reporters={ \"name\": \"" + reporter + "\", \"options\": ";
            var options = '{}';
            if (config.filename && config.directory) {
                fs_extra_1.ensureDirSync(config.directory);
                options = "{ \"directory\": \"" + config.directory + "\", \"filename\": \"" + config.filename + "\" }";
            }
            else if (config.directory) {
                fs_extra_1.ensureDirSync(config.directory);
                options = "{ \"directory\": \"" + config.directory + "\" }";
            }
            else {
                var directory = path.parse(config.filename).dir;
                fs_extra_1.ensureDirSync(directory);
                options = "{ \"filename\": \"" + config.filename + "\" }";
            }
            return "" + reporterConfig + options + " }";
        });
        if (formattedReporters.length) {
            if (includeRunner_1) {
                args.push('reporters=runner');
            }
            args.push.apply(args, tslib_1.__spread(formattedReporters));
        }
    }
    if (userName && testingKey) {
        args.push("tunnelOptions={ \"username\": \"" + userName + "\", \"accessKey\": \"" + testingKey + "\" }");
    }
    var capabilitiesBase = "capabilities={ \"name\": \"" + dirname_1.projectName() + "\", \"project\": \"" + dirname_1.projectName() + "\"";
    if (childConfig === 'browserstack') {
        args.push(capabilitiesBase + ', "fixSessionCapabilities": "false", "browserstack.debug": "false" }');
    }
    else if (childConfig === 'saucelabs') {
        args.push(capabilitiesBase + ', "fixSessionCapabilities": "false" }');
    }
    else {
        args.push(capabilitiesBase + ' }');
    }
    return tslib_1.__spread(args);
}
exports.parseArguments = parseArguments;
function setLogger(value) {
    logger = value;
}
exports.setLogger = setLogger;
function default_1(testArgs) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var testRunPromise;
        return tslib_1.__generator(this, function (_a) {
            testRunPromise = new Promise(function (resolve, reject) {
                var internPath = path.resolve('node_modules/.bin/intern');
                var internArgs = parseArguments(testArgs);
                function succeed() {
                    logger('\n  ' + chalk_1.default.green('testing') + ' completed successfully');
                    resolve();
                }
                function fail(err) {
                    logger('\n  ' + chalk_1.default.red('testing') + ' failed');
                    reject({
                        message: err,
                        exitCode: 1
                    });
                }
                logger('\n' + chalk_1.default.underline("testing \"" + dirname_1.projectName() + "\"...") + "\n");
                if (testArgs.verbose) {
                    logger("" + chalk_1.default.blue.bold('  Intern config:'));
                    logger('    ' + chalk_1.default.blue(String(cs.sync(internPath, tslib_1.__spread(['showConfig'], internArgs)).stdout)));
                    logger("" + chalk_1.default.blue.bold('  Parsed arguments for intern:'));
                    logger('    ' + chalk_1.default.blue(String(internArgs.join('\n    '))));
                }
                cs.spawn(internPath, internArgs, { stdio: 'inherit' })
                    .on('close', function (exitCode) {
                    if (exitCode) {
                        fail('Tests did not complete successfully');
                    }
                    else {
                        succeed();
                    }
                })
                    .on('error', function (err) {
                    fail(err.message);
                });
            });
            return [2 /*return*/, testRunPromise];
        });
    });
}
exports.default = default_1;
//# sourceMappingURL=runTests.js.map