var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "chalk", "path", "./dirname"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const chalk_1 = require("chalk");
    const path = require("path");
    const dirname_1 = require("./dirname");
    const cs = require('cross-spawn');
    const pkgDir = require('pkg-dir');
    const packagePath = pkgDir.sync(dirname_1.default);
    let logger = console.log;
    function parseArguments(testArgs) {
        const { nodeUnit, remoteUnit, remoteFunctional, childConfig, internConfig, reporters, secret, testingKey, userName, filter } = testArgs;
        const configArg = childConfig ? `@${childConfig}` : '';
        const args = [
            internConfig
                ? `config=${path.relative(process.cwd(), internConfig)}`
                : `config=${path.relative(process.cwd(), path.join(packagePath, 'intern', 'intern.json' + configArg))}`
        ];
        args.push(`basePath=${process.cwd()}`);
        // by default, in the intern config, all tests are run. we need to
        // disable tests that we dont want to run
        if (!remoteUnit && !nodeUnit) {
            args.push('suites=');
        }
        if (!remoteUnit && !remoteFunctional) {
            args.push('environments=');
        }
        else if (!remoteFunctional) {
            args.push('functionalSuites=');
        }
        if (filter) {
            args.push('grep=' + filter);
        }
        args.push(...(reporters ? reporters.split(',').map((reporter) => `reporters=${reporter}`) : []));
        if (userName && testingKey) {
            args.push(`tunnelOptions={ "username": "${userName}", "accessKey": "${testingKey}" }`);
        }
        const capabilitiesBase = `capabilities={ "name": "${dirname_1.projectName()}", "project": "${dirname_1.projectName()}"`;
        if (childConfig === 'browserstack') {
            args.push(capabilitiesBase + ', "fixSessionCapabilities": "false", "browserstack.debug": "false" }');
        }
        else if (childConfig === 'saucelabs') {
            args.push(capabilitiesBase + ', "fixSessionCapabilities": "false" }');
        }
        else {
            args.push(capabilitiesBase + ' }');
        }
        return [...args];
    }
    exports.parseArguments = parseArguments;
    function setLogger(value) {
        logger = value;
    }
    exports.setLogger = setLogger;
    function default_1(testArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const testRunPromise = new Promise((resolve, reject) => {
                function succeed() {
                    logger('\n  ' + chalk_1.green('testing') + ' completed successfully');
                    resolve();
                }
                function fail(err) {
                    logger('\n  ' + chalk_1.red('testing') + ' failed');
                    reject({
                        message: err,
                        exitCode: 1
                    });
                }
                logger('\n' + chalk_1.underline(`testing "${dirname_1.projectName()}"...`) + `\n`);
                if (testArgs.verbose) {
                    logger(`${chalk_1.blue.bold('  Parsed arguments for intern:')}`);
                    logger('    ' + chalk_1.blue(String(parseArguments(testArgs).join('\n    '))));
                }
                cs.spawn(path.resolve('node_modules/.bin/intern'), parseArguments(testArgs), { stdio: 'inherit' })
                    .on('close', (exitCode) => {
                    if (exitCode) {
                        fail('Tests did not complete successfully');
                    }
                    else {
                        succeed();
                    }
                })
                    .on('error', (err) => {
                    fail(err.message);
                });
            });
            return testRunPromise;
        });
    }
    exports.default = default_1;
});
//# sourceMappingURL=runTests.js.map