(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "@dojo/core/Evented", "@dojo/core/has", "@dojo/core/lang", "@dojo/core/load", "@dojo/shim/global", "@dojo/shim/Map", "@dojo/shim/Observable", "@dojo/shim/Promise", "globalize/dist/globalize/message", "./cldr/load", "./util/main"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    /* tslint:disable:interface-name */
    var Evented_1 = require("@dojo/core/Evented");
    var has_1 = require("@dojo/core/has");
    var lang_1 = require("@dojo/core/lang");
    var load_1 = require("@dojo/core/load");
    var global_1 = require("@dojo/shim/global");
    var Map_1 = require("@dojo/shim/Map");
    var Observable_1 = require("@dojo/shim/Observable");
    var Promise_1 = require("@dojo/shim/Promise");
    var Globalize = require("globalize/dist/globalize/message");
    var load_2 = require("./cldr/load");
    var main_1 = require("./util/main");
    var PATH_SEPARATOR = has_1.default('host-node') ? require('path').sep : '/';
    var TOKEN_PATTERN = /\{([a-z0-9_]+)\}/gi;
    var VALID_PATH_PATTERN = new RegExp("\\" + PATH_SEPARATOR + "[^\\" + PATH_SEPARATOR + "]+$");
    var bundleMap = new Map_1.default();
    var formatterMap = new Map_1.default();
    var localeProducer = new Evented_1.default({});
    var rootLocale;
    /**
     * @private
     * Return a function that formats an ICU-style message, and takes an optional value for token replacement.
     *
     * Usage:
     * const formatter = getMessageFormatter(bundlePath, 'guestInfo', 'fr');
     * const message = formatter({
     *   host: 'Miles',
     *   gender: 'male',
     *   guest: 'Oscar',
     *   guestCount: '15'
     * });
     *
     * @param bundlePath
     * The message's bundle path.
     *
     * @param key
     * The message's key.
     *
     * @param locale
     * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
     * default locale is used.
     *
     * @return
     * The message formatter.
     */
    function getIcuMessageFormatter(bundlePath, key, locale) {
        var normalized = bundlePath.replace(new RegExp("\\" + PATH_SEPARATOR, 'g'), '-').replace(/-$/, '');
        locale = main_1.normalizeLocale(locale || getRootLocale());
        var formatterKey = locale + ":" + bundlePath + ":" + key;
        var formatter = formatterMap.get(formatterKey);
        if (formatter) {
            return formatter;
        }
        var globalize = locale !== getRootLocale() ? new Globalize(main_1.normalizeLocale(locale)) : Globalize;
        formatter = globalize.messageFormatter(normalized + "/" + key);
        var cached = bundleMap.get(bundlePath);
        if (cached && cached.get(locale)) {
            formatterMap.set(formatterKey, formatter);
        }
        return formatter;
    }
    /**
     * @private
     * Load the specified locale-specific bundles, mapping the default exports to simple `Messages` objects.
     */
    var loadLocaleBundles = (function () {
        function mapMessages(modules) {
            return modules.map(function (localeModule) { return load_1.useDefault(localeModule); });
        }
        return function (paths) {
            return load_1.default.apply(void 0, tslib_1.__spread([require], paths)).then(function (modules) {
                return mapMessages(modules);
            });
        };
    })();
    /**
     * @private
     * Return the root locale. Defaults to the system locale.
     */
    function getRootLocale() {
        return rootLocale || exports.systemLocale;
    }
    /**
     * @private
     * Retrieve a list of supported locales that can provide messages for the specified locale.
     *
     * @param locale
     * The target locale.
     *
     * @param supported
     * The locales that are supported by the bundle.
     *
     * @return
     * A list of supported locales that match the target locale.
     */
    function getSupportedLocales(locale, supported) {
        if (supported === void 0) { supported = []; }
        return main_1.generateLocales(locale).filter(function (locale) { return supported.indexOf(locale) > -1; });
    }
    /**
     * @private
     * Inject messages for the specified locale into the i18n system.
     *
     * @param bundlePath
     * The bundle path
     *
     * @param messages
     * The messages to inject
     *
     * @param locale
     * An optional locale. If not specified, then it is assumed that the messages are the defaults for the given
     * bundle path.
     */
    function loadMessages(bundlePath, messages, locale) {
        if (locale === void 0) { locale = 'root'; }
        var cached = bundleMap.get(bundlePath);
        if (!cached) {
            cached = new Map_1.default();
            bundleMap.set(bundlePath, cached);
        }
        cached.set(locale, messages);
        Globalize.loadMessages((_a = {},
            _a[locale] = (_b = {},
                _b[bundlePath.replace(new RegExp("\\" + PATH_SEPARATOR, 'g'), '-')] = messages,
                _b),
            _a));
        var _a, _b;
    }
    /**
     * @private
     * Return a list of locale path bundles for a target locale.
     *
     * @param path
     * The default bundle path.
     *
     * @param locale
     * The target locale
     *
     * @param supported
     * A list of locales with their own bundles.
     *
     * @return Paths for locale bundles to be loaded.
     */
    function resolveLocalePaths(path, locale, supported) {
        validatePath(path);
        var filename;
        var parentDirectory = path.replace(VALID_PATH_PATTERN, function (matched) {
            filename = matched;
            return PATH_SEPARATOR;
        });
        var locales = getSupportedLocales(locale, supported);
        return locales.map(function (locale) {
            return "" + parentDirectory + locale + filename;
        });
    }
    /**
     * @private
     * Ensure a path follows the required format for loading locale-specific bundles.
     *
     * @param path
     * The default bundle path to validate.
     */
    function validatePath(path) {
        if (!VALID_PATH_PATTERN.test(path)) {
            var message = 'Invalid i18n bundle path. Bundle maps must adhere to the format' +
                ' "{basePath}{separator}{bundleName}" so that locale bundles can be resolved.';
            throw new Error(message);
        }
    }
    /**
     * Return a formatted message.
     *
     * If both the "supplemental/likelySubtags" and "supplemental/plurals-type-cardinal" CLDR data have been loaded, then
     * the ICU message format is supported. Otherwise, a simple token-replacement mechanism is used.
     *
     * Usage:
     * formatMessage(bundle.bundlePath, 'guestInfo', {
     *   host: 'Bill',
     *   guest: 'John'
     * }, 'fr');
     *
     * @param bundlePath
     * The message's bundle path.
     *
     * @param key
     * The message's key.
     *
     * @param options
     * An optional value used by the formatter to replace tokens with values.
     *
     * @param locale
     * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
     * default locale is used.
     *
     * @return
     * The formatted message.
     */
    function formatMessage(bundlePath, key, options, locale) {
        return getMessageFormatter(bundlePath, key, locale)(options);
    }
    exports.formatMessage = formatMessage;
    /**
     * Return the cached messages for the specified bundle and locale. If messages have not been previously loaded for the
     * specified locale, no value will be returned. If messages for the specified locale were added via
     * `setLocaleMessages`, then those messages will be returned regardless of whether the locale is listed in the bundle's
     * `locales` array.
     *
     * @param bundle
     * The default bundle that is used to determine where the locale-specific bundles are located.
     *
     * @param locale
     * The locale of the desired messages.
     *
     * @return The cached messages object, if it exists.
     */
    function getCachedMessages(bundle, locale) {
        var bundlePath = bundle.bundlePath, locales = bundle.locales, messages = bundle.messages;
        var cached = bundleMap.get(bundlePath);
        if (!cached) {
            loadMessages(bundlePath, messages);
        }
        else {
            var localeMessages = cached.get(locale);
            if (localeMessages) {
                return localeMessages;
            }
        }
        var supportedLocales = getSupportedLocales(locale, locales);
        if (!supportedLocales.length) {
            return messages;
        }
        if (cached) {
            return cached.get(supportedLocales[supportedLocales.length - 1]);
        }
    }
    exports.getCachedMessages = getCachedMessages;
    /**
     * Return a function that formats a specific message, and takes an optional value for token replacement.
     *
     * If both the "supplemental/likelySubtags" and "supplemental/plurals-type-cardinal" CLDR data have been loaded, then
     * the returned function will have ICU message format support. Otherwise, the returned function will perform a simple
     * token replacement on the message string.
     *
     * Usage:
     * const formatter = getMessageFormatter(bundlePath, 'guestInfo', 'fr');
     * const message = formatter({
     *   host: 'Miles',
     *   gender: 'male',
     *   guest: 'Oscar',
     *   guestCount: '15'
     * });
     *
     * @param bundlePath
     * The message's bundle path.
     *
     * @param key
     * The message's key.
     *
     * @param locale
     * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
     * default locale is used.
     *
     * @return
     * The message formatter.
     */
    function getMessageFormatter(bundlePath, key, locale) {
        if (load_2.isLoaded('supplemental', 'likelySubtags') && load_2.isLoaded('supplemental', 'plurals-type-cardinal')) {
            return getIcuMessageFormatter(bundlePath, key, locale);
        }
        var cached = bundleMap.get(bundlePath);
        var messages = cached ? (cached.get(locale || getRootLocale()) || cached.get('root')) : null;
        if (!messages) {
            throw new Error("The bundle \"" + bundlePath + "\" has not been registered.");
        }
        return function (options) {
            if (options === void 0) { options = Object.create(null); }
            return messages[key].replace(TOKEN_PATTERN, function (token, property) {
                var value = options[property];
                if (typeof value === 'undefined') {
                    throw new Error("Missing property " + property);
                }
                return value;
            });
        };
    }
    exports.getMessageFormatter = getMessageFormatter;
    /**
     * Load locale-specific messages for the specified bundle and locale.
     *
     * @param bundle
     * The default bundle that is used to determine where the locale-specific bundles are located.
     *
     * @param locale
     * An optional locale. If no locale is provided, then the current locale is assumed.
     *
     * @return A promise to the locale-specific messages.
     */
    function i18n(bundle, locale) {
        var bundlePath = bundle.bundlePath, locales = bundle.locales, messages = bundle.messages;
        var path = bundlePath.replace(new RegExp("\\" + PATH_SEPARATOR + "$"), '');
        var currentLocale = locale ? main_1.normalizeLocale(locale) : getRootLocale();
        try {
            validatePath(path);
        }
        catch (error) {
            return Promise_1.default.reject(error);
        }
        var cachedMessages = getCachedMessages(bundle, currentLocale);
        if (cachedMessages) {
            return Promise_1.default.resolve(cachedMessages);
        }
        var localePaths = resolveLocalePaths(path, currentLocale, locales);
        return loadLocaleBundles(localePaths).then(function (bundles) {
            return bundles.reduce(function (previous, partial) {
                var localeMessages = lang_1.assign({}, previous, partial);
                loadMessages(bundlePath, Object.freeze(localeMessages), currentLocale);
                return localeMessages;
            }, messages);
        });
    }
    Object.defineProperty(i18n, 'locale', {
        get: getRootLocale
    });
    exports.default = i18n;
    /**
     * Invalidate the cache for a particular bundle, or invalidate the entire cache. Note that cached messages for all
     * locales for a given bundle will be cleared.
     *
     * @param bundlePath
     * The optional path of the bundle to invalidate. If no path is provided, then the cache is cleared for all bundles.
     */
    function invalidate(bundlePath) {
        if (bundlePath) {
            bundleMap.delete(bundlePath);
        }
        else {
            bundleMap.clear();
        }
    }
    exports.invalidate = invalidate;
    /**
     * Register an observer to be notified when the root locale changes.
     *
     * @param observer
     * The observer whose `next` method will receive the locale string on updates, and whose `error` method will receive
     * an Error object if the locale switch fails.
     *
     * @return
     * A subscription object that can be used to unsubscribe from updates.
     */
    exports.observeLocale = (function () {
        var localeSource = new Observable_1.default(function (observer) {
            var handles = [
                localeProducer.on('change', function (event) {
                    observer.next(event.target);
                })
            ];
            return function () {
                handles.forEach(function (handle) {
                    handle.destroy();
                });
            };
        });
        return function (observer) {
            return localeSource.subscribe(observer);
        };
    })();
    /**
     * Pre-load locale-specific messages into the i18n system.
     *
     * @param bundle
     * The default bundle that is used to merge locale-specific messages with the default messages.
     *
     * @param messages
     * The messages to cache.
     *
     * @param locale
     * The locale for the messages
     */
    function setLocaleMessages(bundle, localeMessages, locale) {
        var messages = lang_1.assign({}, bundle.messages, localeMessages);
        loadMessages(bundle.bundlePath, Object.freeze(messages), locale);
    }
    exports.setLocaleMessages = setLocaleMessages;
    /**
     * Change the root locale, and notify any registered observers.
     *
     * @param locale
     * The new locale.
     */
    function switchLocale(locale) {
        var previous = rootLocale;
        rootLocale = locale ? main_1.normalizeLocale(locale) : '';
        if (previous !== rootLocale) {
            if (load_2.isLoaded('supplemental', 'likelySubtags')) {
                Globalize.load({
                    main: (_a = {},
                        _a[rootLocale] = {},
                        _a)
                });
                Globalize.locale(rootLocale);
            }
            localeProducer.emit({ type: 'change', target: rootLocale });
        }
        var _a;
    }
    exports.switchLocale = switchLocale;
    /**
     * The default environment locale.
     *
     * It should be noted that while the system locale will be normalized to a single
     * format when loading message bundles, this value represents the unaltered
     * locale returned directly by the environment.
     */
    exports.systemLocale = (function () {
        var systemLocale = 'en';
        if (has_1.default('host-browser')) {
            var navigator_1 = global_1.default.navigator;
            systemLocale = navigator_1.language || navigator_1.userLanguage;
        }
        else if (has_1.default('host-node')) {
            systemLocale = process.env.LANG || systemLocale;
        }
        return main_1.normalizeLocale(systemLocale);
    })();
});
//# sourceMappingURL=i18n.js.map