{"version":3,"file":"path.js","sourceRoot":"","sources":["path.ts"],"names":[],"mappings":"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","sourcesContent":["import UrlSearchParams from '@dojo/core/UrlSearchParams';\n\nexport interface ParsedPath {\n\t/**\n\t * Parameters extracted from the search component.\n\t */\n\tsearchParams: UrlSearchParams;\n\n\t/**\n\t * Pathname segments.\n\t */\n\tsegments: string[];\n\n\t/**\n\t * Whether the pathname ended with a trailing slash.\n\t */\n\ttrailingSlash: boolean;\n}\n\n/**\n * Parses a path\n * @param path The path to parse.\n * @return The search params, pathname segments, and whether it ended with a trailing slash.\n */\nexport function parse(path: string): ParsedPath {\n\tconst tokens: string[] = path.split(/([/?#])/).filter(Boolean);\n\n\tlet pathnameTokens = tokens;\n\tlet searchParams: UrlSearchParams;\n\n\tconst searchStart = tokens.indexOf('?');\n\tconst hashStart = tokens.indexOf('#');\n\tif (searchStart >= 0) {\n\t\tif (hashStart >= 0) {\n\t\t\t// Either `/foo?bar#baz` or `/foo#bar?baz`\n\t\t\tpathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n\t\t\tsearchParams = new UrlSearchParams(tokens.slice(searchStart + 1, hashStart).join(''));\n\t\t}\n\t\telse {\n\t\t\t// `/foo?bar`\n\t\t\tpathnameTokens = tokens.slice(0, searchStart);\n\t\t\tsearchParams = new UrlSearchParams(tokens.slice(searchStart + 1).join(''));\n\t\t}\n\t}\n\telse {\n\t\tsearchParams = new UrlSearchParams();\n\t\tif (hashStart >= 0) {\n\t\t\t// `/foo#bar`\n\t\t\tpathnameTokens = tokens.slice(0, hashStart);\n\t\t}\n\t}\n\n\tconst segments = pathnameTokens.filter(t => t !== '/');\n\tconst trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n\n\treturn {\n\t\tsearchParams,\n\t\tsegments,\n\t\ttrailingSlash\n\t};\n}\n\nexport interface MatchResult {\n\t/**\n\t * Whether there are remaining segments that weren't matched.\n\t */\n\thasRemaining: boolean;\n\n\t/**\n\t * Position in the segments array that the remaining unmatched segments start.\n\t */\n\toffset: number;\n\n\t/**\n\t * Values for named segments.\n\t */\n\tvalues: string[];\n}\n\n/**\n * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n * @param expectedSegments Part of a DeconstructedPath object.\n * @param segments Pathname segments as returned by `parse()`\n * @return A result object.\n */\nexport function match({ expectedSegments }: DeconstructedPath, segments: string[]): MatchResult | null {\n\tif (expectedSegments.length === 0) {\n\t\treturn {\n\t\t\thasRemaining: segments.length > 0,\n\t\t\toffset: 0,\n\t\t\tvalues: []\n\t\t};\n\t}\n\n\tif (expectedSegments.length > segments.length) {\n\t\treturn null;\n\t}\n\n\tlet isMatch = true;\n\tconst values: string[] = [];\n\tfor (let i = 0; isMatch && i < expectedSegments.length; i++) {\n\t\tconst value = segments[i];\n\t\tconst expected = expectedSegments[i];\n\t\tif (isNamedSegment(expected)) {\n\t\t\tvalues.push(value);\n\t\t}\n\t\telse if (expected.literal !== value) {\n\t\t\tisMatch = false;\n\t\t}\n\t}\n\n\tif (!isMatch) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\thasRemaining: expectedSegments.length < segments.length,\n\t\toffset: expectedSegments.length,\n\t\tvalues\n\t};\n}\n\nexport interface LiteralSegment {\n\tliteral: string;\n}\n\nexport interface NamedSegment {\n\tname: string;\n}\n\nexport type Segment = LiteralSegment | NamedSegment;\n\n/**\n * Determine whether the segment is a NamedSegment.\n *\n * @param segment The segment to be checked\n * @return true if the segment is a NamedSegment, false otherwise\n */\nexport function isNamedSegment(segment: Segment): segment is NamedSegment {\n\treturn (<NamedSegment> segment).name !== undefined;\n}\n\n/**\n * Describes a route path, broken down into its constituent parts.\n */\nexport interface DeconstructedPath {\n\t/**\n\t * Segments (literal and named) that are expected to be present when matching paths.\n\t */\n\texpectedSegments: Segment[];\n\n\t/**\n\t * Whether the pathname started with a slash.\n\t */\n\tleadingSlash: boolean;\n\n\t/**\n\t * Named path parameters, in the order that they occurred in the path.\n\t */\n\tparameters: string[];\n\n\t/**\n\t * Named query parameters, in the order that they occurred in the path.\n\t */\n\tsearchParameters: string[];\n\n\t/**\n\t * Whether the pathname ended with a slash.\n\t */\n\ttrailingSlash: boolean;\n}\n\n/**\n * Deconstruct a route path into its constituent parts.\n * @param path The path to deconstruct.\n * @return An object describing the path's constituent parts.\n */\nexport function deconstruct(path: string): DeconstructedPath {\n\tconst expectedSegments: Segment[] = [];\n\tconst parameters: string[] = [];\n\tconst searchParameters: string[] = [];\n\tlet trailingSlash = false;\n\n\tconst tokens = path.split(/([/{}?&])/).filter(Boolean);\n\tconst leadingSlash = tokens[0] === '/';\n\n\tlet i = 0;\n\tconst consume = () => tokens[i++];\n\tconst peek = () => tokens[i];\n\n\tlet inSearchComponent = false;\n\twhile (i < tokens.length) {\n\t\tconst t = consume();\n\n\t\tswitch (t) {\n\t\t\tcase '{': {\n\t\t\t\tconst name = consume();\n\t\t\t\tif (!name || name === '}') {\n\t\t\t\t\tthrow new TypeError('Parameter must have a name');\n\t\t\t\t}\n\t\t\t\t// Reserve : for future use, e.g. including type data in the parameter declaration.\n\t\t\t\tif (name === '{' || name === '&' || /:/.test(name)) {\n\t\t\t\t\tthrow new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n\t\t\t\t}\n\t\t\t\tif (parameters.indexOf(name) !== -1 || searchParameters.indexOf(name) !== -1) {\n\t\t\t\t\tthrow new TypeError(`Parameter must have a unique name, got '${name}'`);\n\t\t\t\t}\n\n\t\t\t\tconst closing = consume();\n\t\t\t\tif (!closing || closing !== '}') {\n\t\t\t\t\tthrow new TypeError(`Parameter name must be followed by '}', got '${closing}'`);\n\t\t\t\t}\n\n\t\t\t\tconst separator = peek();\n\t\t\t\tif (separator) {\n\t\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\t\tif (separator !== '&') {\n\t\t\t\t\t\t\tthrow new TypeError(`Search parameter must be followed by '&', got '${separator}'`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (separator !== '/' && separator !== '?') {\n\t\t\t\t\t\tthrow new TypeError(`Parameter must be followed by '/' or '?', got '${separator}'`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tsearchParameters.push(name);\n\t\t\t\t} else {\n\t\t\t\t\tparameters.push(name);\n\t\t\t\t\texpectedSegments.push(Object.freeze({ name }));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase '?':\n\t\t\tcase '/':\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tthrow new TypeError(`Expected parameter in search component, got '${t}'`);\n\t\t\t\t}\n\n\t\t\t\tif (t === '?') {\n\t\t\t\t\tinSearchComponent = true;\n\t\t\t\t\tif (expectedSegments.length === 0) {\n\t\t\t\t\t\tthrow new TypeError('Path must contain at least one segment');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (t === '/') {\n\t\t\t\t\tconst next = peek();\n\t\t\t\t\tif (next === '/') {\n\t\t\t\t\t\tthrow new TypeError('Path segment must not be empty');\n\t\t\t\t\t}\n\t\t\t\t\tif (expectedSegments.length > 0 && (!next || next === '?')) {\n\t\t\t\t\t\ttrailingSlash = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tif (!inSearchComponent) {\n\t\t\t\t\tthrow new TypeError('Path segment must not contain \\'&\\'');\n\t\t\t\t}\n\n\t\t\t\tconst next = peek();\n\t\t\t\tif (next === '&') {\n\t\t\t\t\tthrow new TypeError('Expected parameter in search component, got \\'&\\'');\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tthrow new TypeError(`Expected parameter in search component, got '${t}'`);\n\t\t\t\t}\n\n\t\t\t\texpectedSegments.push(Object.freeze({ literal: t }));\n\t\t}\n\t}\n\n\treturn Object.freeze({\n\t\texpectedSegments: <Segment[]> Object.freeze(expectedSegments),\n\t\tleadingSlash,\n\t\tparameters: <string[]> Object.freeze(parameters),\n\t\tsearchParameters: <string[]> Object.freeze(searchParameters),\n\t\ttrailingSlash\n\t});\n}\n"]}