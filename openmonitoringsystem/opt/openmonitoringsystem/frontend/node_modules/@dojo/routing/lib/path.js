(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/UrlSearchParams"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UrlSearchParams_1 = require("@dojo/core/UrlSearchParams");
    /**
     * Parses a path
     * @param path The path to parse.
     * @return The search params, pathname segments, and whether it ended with a trailing slash.
     */
    function parse(path) {
        var tokens = path.split(/([/?#])/).filter(Boolean);
        var pathnameTokens = tokens;
        var searchParams;
        var searchStart = tokens.indexOf('?');
        var hashStart = tokens.indexOf('#');
        if (searchStart >= 0) {
            if (hashStart >= 0) {
                // Either `/foo?bar#baz` or `/foo#bar?baz`
                pathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));
                searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1, hashStart).join(''));
            }
            else {
                // `/foo?bar`
                pathnameTokens = tokens.slice(0, searchStart);
                searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1).join(''));
            }
        }
        else {
            searchParams = new UrlSearchParams_1.default();
            if (hashStart >= 0) {
                // `/foo#bar`
                pathnameTokens = tokens.slice(0, hashStart);
            }
        }
        var segments = pathnameTokens.filter(function (t) { return t !== '/'; });
        var trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;
        return {
            searchParams: searchParams,
            segments: segments,
            trailingSlash: trailingSlash
        };
    }
    exports.parse = parse;
    /**
     * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.
     * @param expectedSegments Part of a DeconstructedPath object.
     * @param segments Pathname segments as returned by `parse()`
     * @return A result object.
     */
    function match(_a, segments) {
        var expectedSegments = _a.expectedSegments;
        if (expectedSegments.length === 0) {
            return {
                hasRemaining: segments.length > 0,
                offset: 0,
                values: []
            };
        }
        if (expectedSegments.length > segments.length) {
            return null;
        }
        var isMatch = true;
        var values = [];
        for (var i = 0; isMatch && i < expectedSegments.length; i++) {
            var value = segments[i];
            var expected = expectedSegments[i];
            if (isNamedSegment(expected)) {
                values.push(value);
            }
            else if (expected.literal !== value) {
                isMatch = false;
            }
        }
        if (!isMatch) {
            return null;
        }
        return {
            hasRemaining: expectedSegments.length < segments.length,
            offset: expectedSegments.length,
            values: values
        };
    }
    exports.match = match;
    /**
     * Determine whether the segment is a NamedSegment.
     *
     * @param segment The segment to be checked
     * @return true if the segment is a NamedSegment, false otherwise
     */
    function isNamedSegment(segment) {
        return segment.name !== undefined;
    }
    exports.isNamedSegment = isNamedSegment;
    /**
     * Deconstruct a route path into its constituent parts.
     * @param path The path to deconstruct.
     * @return An object describing the path's constituent parts.
     */
    function deconstruct(path) {
        var expectedSegments = [];
        var parameters = [];
        var searchParameters = [];
        var trailingSlash = false;
        var tokens = path.split(/([/{}?&])/).filter(Boolean);
        var leadingSlash = tokens[0] === '/';
        var i = 0;
        var consume = function () { return tokens[i++]; };
        var peek = function () { return tokens[i]; };
        var inSearchComponent = false;
        while (i < tokens.length) {
            var t = consume();
            switch (t) {
                case '{': {
                    var name_1 = consume();
                    if (!name_1 || name_1 === '}') {
                        throw new TypeError('Parameter must have a name');
                    }
                    // Reserve : for future use, e.g. including type data in the parameter declaration.
                    if (name_1 === '{' || name_1 === '&' || /:/.test(name_1)) {
                        throw new TypeError('Parameter name must not contain \'{\', \'&\' or \':\'');
                    }
                    if (parameters.indexOf(name_1) !== -1 || searchParameters.indexOf(name_1) !== -1) {
                        throw new TypeError("Parameter must have a unique name, got '" + name_1 + "'");
                    }
                    var closing = consume();
                    if (!closing || closing !== '}') {
                        throw new TypeError("Parameter name must be followed by '}', got '" + closing + "'");
                    }
                    var separator = peek();
                    if (separator) {
                        if (inSearchComponent) {
                            if (separator !== '&') {
                                throw new TypeError("Search parameter must be followed by '&', got '" + separator + "'");
                            }
                        }
                        else if (separator !== '/' && separator !== '?') {
                            throw new TypeError("Parameter must be followed by '/' or '?', got '" + separator + "'");
                        }
                    }
                    if (inSearchComponent) {
                        searchParameters.push(name_1);
                    }
                    else {
                        parameters.push(name_1);
                        expectedSegments.push(Object.freeze({ name: name_1 }));
                    }
                    break;
                }
                case '?':
                case '/':
                    if (inSearchComponent) {
                        throw new TypeError("Expected parameter in search component, got '" + t + "'");
                    }
                    if (t === '?') {
                        inSearchComponent = true;
                        if (expectedSegments.length === 0) {
                            throw new TypeError('Path must contain at least one segment');
                        }
                    }
                    if (t === '/') {
                        var next_1 = peek();
                        if (next_1 === '/') {
                            throw new TypeError('Path segment must not be empty');
                        }
                        if (expectedSegments.length > 0 && (!next_1 || next_1 === '?')) {
                            trailingSlash = true;
                        }
                    }
                    break;
                case '&':
                    if (!inSearchComponent) {
                        throw new TypeError('Path segment must not contain \'&\'');
                    }
                    var next = peek();
                    if (next === '&') {
                        throw new TypeError('Expected parameter in search component, got \'&\'');
                    }
                    break;
                default:
                    if (inSearchComponent) {
                        throw new TypeError("Expected parameter in search component, got '" + t + "'");
                    }
                    expectedSegments.push(Object.freeze({ literal: t }));
            }
        }
        return Object.freeze({
            expectedSegments: Object.freeze(expectedSegments),
            leadingSlash: leadingSlash,
            parameters: Object.freeze(parameters),
            searchParameters: Object.freeze(searchParameters),
            trailingSlash: trailingSlash
        });
    }
    exports.deconstruct = deconstruct;
});
//# sourceMappingURL=path.js.map