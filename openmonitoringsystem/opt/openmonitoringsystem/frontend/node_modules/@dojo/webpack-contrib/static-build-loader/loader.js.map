{"version":3,"file":"loader.js","sourceRoot":"","sources":["loader.ts"],"names":[],"mappings":"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","sourcesContent":["import getFeatures from './getFeatures';\nimport { LoaderContext, RawSourceMap } from 'webpack';\nimport * as recast from 'recast';\n\nconst { getOptions } = require('loader-utils');\nconst types = recast.types;\nconst namedTypes = types.namedTypes;\nconst builders = types.builders;\nconst compose = require('recast/lib/util').composeSourceMaps;\n\n/**\n * A map of features that should be statically replaced in the code\n */\nexport interface StaticHasFeatures {\n\t[feature: string]: boolean;\n}\n\nconst HAS_MID = /\\/has$/;\nconst HAS_PRAGMA = /^\\s*(!?)\\s*has\\s*\\([\"']([^'\"]+)['\"]\\)\\s*$/;\n\n/**\n * Checks code for usage of has pragmas or other calls to @dojo/has and optimizes them out based on the flags or\n * feature sets specified statically. This loader should act on JavaScript, so it should run after the compiler\n * if using TypeScript\n * @param content The JavaScript code to optimize\n * @param sourceMap Optional Source map for the code. If provided it will be updated to reflect the optimizations made\n */\nexport default function loader(this: LoaderContext, content: string, sourceMap?: RawSourceMap): string | void {\n\tif (content.indexOf('/has') < 0 && content.indexOf('has(') < 0) {\n\t\tif (sourceMap) {\n\t\t\tthis.callback(null, content, sourceMap);\n\t\t\treturn;\n\t\t}\n\t\treturn content;\n\t}\n\t// copy features to a local scope, because `this` gets weird\n\tconst options = getOptions(this);\n\tconst { features: featuresOption } = options;\n\tconst parseOptions =\n\t\t(sourceMap && {\n\t\t\tsourceFileName: sourceMap.file\n\t\t}) ||\n\t\tundefined;\n\tconst dynamicFlags = new Set<string>();\n\tconst ast = recast.parse(content, parseOptions);\n\tlet features: StaticHasFeatures;\n\tlet elideNextImport = false;\n\tlet hasIdentifier: string | undefined;\n\n\tif (!featuresOption || Array.isArray(featuresOption) || typeof featuresOption === 'string') {\n\t\tfeatures = getFeatures(featuresOption);\n\t} else {\n\t\tfeatures = featuresOption;\n\t}\n\n\ttypes.visit(ast, {\n\t\tvisitExpressionStatement(path) {\n\t\t\tconst { node, parentPath, name } = path;\n\t\t\tlet comment;\n\t\t\tif (namedTypes.Literal.check(node.expression) && typeof node.expression.value === 'string') {\n\t\t\t\tconst hasPragma = HAS_PRAGMA.exec(node.expression.value);\n\t\t\t\tif (hasPragma) {\n\t\t\t\t\tconst [, negate, flag] = hasPragma;\n\t\t\t\t\tcomment = ` ${negate}has('${flag}')`;\n\t\t\t\t\tif (flag in features) {\n\t\t\t\t\t\telideNextImport = negate ? !features[flag] : features[flag];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tnamedTypes.CallExpression.check(node.expression) &&\n\t\t\t\tnamedTypes.Identifier.check(node.expression.callee)\n\t\t\t) {\n\t\t\t\tif (\n\t\t\t\t\tnode.expression.callee.name === 'require' &&\n\t\t\t\t\tnode.expression.arguments.length === 1 &&\n\t\t\t\t\telideNextImport === true\n\t\t\t\t) {\n\t\t\t\t\tconst [arg] = node.expression.arguments;\n\t\t\t\t\tif (namedTypes.Literal.check(arg)) {\n\t\t\t\t\t\tcomment = ` elided: import '${arg.value}'`;\n\t\t\t\t\t\telideNextImport = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (comment && parentPath && typeof name !== 'undefined') {\n\t\t\t\tconst next = (Array.isArray(parentPath.value) && parentPath.value[Number(name) + 1]) || parentPath.node;\n\t\t\t\tnext.comments = [\n\t\t\t\t\t...((node as any).comments || []),\n\t\t\t\t\t...(next.comments || []),\n\t\t\t\t\tbuilders.commentLine(comment)\n\t\t\t\t];\n\t\t\t\tpath.replace(null);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.traverse(path);\n\t\t},\n\n\t\t// Look for `require('*/has');` and set the variable name to `hasIdentifier`\n\t\tvisitVariableDeclaration(path) {\n\t\t\tconst { parentPath: { node: parentNode }, node: { declarations } } = path;\n\t\t\t// Get all the top level variable declarations\n\t\t\tif (ast.program === parentNode && !hasIdentifier) {\n\t\t\t\tdeclarations.forEach(({ id, init }) => {\n\t\t\t\t\tif (!hasIdentifier) {\n\t\t\t\t\t\tif (namedTypes.Identifier.check(id) && init && namedTypes.CallExpression.check(init)) {\n\t\t\t\t\t\t\tconst { callee, arguments: args } = init;\n\t\t\t\t\t\t\tif (namedTypes.Identifier.check(callee) && callee.name === 'require' && args.length === 1) {\n\t\t\t\t\t\t\t\tconst [arg] = args;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tnamedTypes.Literal.check(arg) &&\n\t\t\t\t\t\t\t\t\ttypeof arg.value === 'string' &&\n\t\t\t\t\t\t\t\t\tHAS_MID.test(arg.value)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\thasIdentifier = id.name;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.traverse(path);\n\t\t}\n\t});\n\n\t// Now we want to walk the AST and find an expressions where the default import of `*/has` is\n\t// called. Which is a CallExpression, where the callee is an object named the import from above\n\t// accessing the `default` property, with one argument, which is a string literal.\n\tif (hasIdentifier) {\n\t\ttypes.visit(ast, {\n\t\t\tvisitCallExpression(path) {\n\t\t\t\tconst { node: { arguments: args, callee } } = path;\n\n\t\t\t\tif (\n\t\t\t\t\tnamedTypes.MemberExpression.check(callee) &&\n\t\t\t\t\tnamedTypes.Identifier.check(callee.object) &&\n\t\t\t\t\tcallee.object.name === hasIdentifier &&\n\t\t\t\t\tnamedTypes.Identifier.check(callee.property) &&\n\t\t\t\t\tcallee.property.name === 'default' &&\n\t\t\t\t\targs.length === 1\n\t\t\t\t) {\n\t\t\t\t\tconst [arg] = args;\n\t\t\t\t\tif (namedTypes.Literal.check(arg) && typeof arg.value === 'string') {\n\t\t\t\t\t\t// check to see if we have a flag that we want to statically swap\n\t\t\t\t\t\tif (arg.value in features) {\n\t\t\t\t\t\t\tpath.replace(builders.literal(Boolean(features[arg.value])));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdynamicFlags.add(arg.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.traverse(path);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (dynamicFlags.size > 0) {\n\t\tconsole.log();\n\t\tconsole.log('Dynamic features: ' + Array.from(dynamicFlags).join(', '));\n\t\tconsole.log();\n\t}\n\tif (sourceMap) {\n\t\tconst result = recast.print(ast, { sourceMapName: sourceMap.file });\n\t\tconst map = compose(sourceMap, result.map);\n\t\tthis.callback(null, result.code, map, ast);\n\t\treturn;\n\t}\n\treturn recast.print(ast).code;\n}\n"]}