{"version":3,"file":"getFeatures.js","sourceRoot":"","sources":["getFeatures.ts"],"names":[],"mappings":";;AAGA;;;;GAIG;AACH,SAAS,IAAI,CAAC,GAAW;IACxB,IAAI;QACH,OAAO,OAAO,CAAC,GAAG,CAAe,CAAC;KAClC;IAAC,OAAO,CAAC,EAAE,GAAE;AACf,CAAC;AAED;;;;GAIG;AACH,SAAwB,WAAW,CAAC,QAAmB;IACtD,iEAAiE;IACjE,IAAI,CAAC,QAAQ,EAAE;QACd,OAAO,EAAE,CAAC;KACV;IAED,MAAM,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;IACrE,MAAM,WAAW,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,cAAc,IAAI,OAAO,CAAC,CAAC,CAAC;IAEhF,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE;QAC7C,WAAW,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;YACnC,IAAI,CAAC,MAAM,EAAE;gBACZ,OAAO,CAAC,GAAG,CAAC,6BAA6B,EAAE,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC;aAC9D;QACF,CAAC,CAAC,CAAC;QACH,OAAO,EAAE,CAAC;KACV;IAED,6FAA6F;IAC7F,yFAAyF;IACzF,MAAM,YAAY,GAAG,IAAI,GAAG,EAAU,CAAC;IACvC,OAAQ,WAA4B,CAAC,MAAM,CAC1C,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE;QACrB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;YACpC,IAAI,CAAC,CAAC,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;gBACjD,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACtB,QAAQ,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;aAC7B;iBAAM,IAAI,GAAG,IAAI,QAAQ,IAAI,QAAQ,CAAC,GAAG,CAAC,KAAK,OAAO,CAAC,GAAG,CAAC,EAAE;gBAC7D,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC;aACrB;QACF,CAAC,CAAC,CAAC;QACH,OAAO,QAAQ,CAAC;IACjB,CAAC,EACD,EAAgB,CAChB,CAAC;AACH,CAAC;AAnCD,8BAmCC","sourcesContent":["export type FeatureMap = { [feature: string]: boolean };\nexport type Features = string | string[];\n\n/**\n * A simple function to return a `FeatureMap` from JSON\n * @param mid MID to JSON file\n * this is running in Node or a browser environment.\n */\nfunction load(mid: string): FeatureMap | undefined {\n\ttry {\n\t\treturn require(mid) as FeatureMap;\n\t} catch (e) {}\n}\n\n/**\n * Retrieve the largest set of non-conflicting features for the supplied feature sets.\n * @param features The features to look for\n * this is running in Node or a browser environment.\n */\nexport default function getFeatures(features?: Features): FeatureMap {\n\t// No features supplied in the args, bail with no static features\n\tif (!features) {\n\t\treturn {};\n\t}\n\n\tconst featureNames = Array.isArray(features) ? features : [features];\n\tconst featureMaps = featureNames.map((name) => load(`./features/${name}.json`));\n\n\tif (!featureMaps.every((exists) => !!exists)) {\n\t\tfeatureMaps.forEach((exists, idx) => {\n\t\t\tif (!exists) {\n\t\t\t\tconsole.log('Cannot resolve feature set:', featureNames[idx]);\n\t\t\t}\n\t\t});\n\t\treturn {};\n\t}\n\n\t// Reduce the array of loaded features to the largest set of features where the values do not\n\t// conflict with each other.  Once a value conflicts, it is removed from the feature map.\n\tconst seenFeatures = new Set<string>();\n\treturn (featureMaps as FeatureMap[]).reduce(\n\t\t(previous, current) => {\n\t\t\tObject.keys(current).forEach((key) => {\n\t\t\t\tif (!(key in previous) && !seenFeatures.has(key)) {\n\t\t\t\t\tseenFeatures.add(key);\n\t\t\t\t\tprevious[key] = current[key];\n\t\t\t\t} else if (key in previous && previous[key] !== current[key]) {\n\t\t\t\t\tdelete previous[key];\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn previous;\n\t\t},\n\t\t{} as FeatureMap\n\t);\n}\n"]}