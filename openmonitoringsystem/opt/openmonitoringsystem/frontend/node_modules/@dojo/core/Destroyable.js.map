{"version":3,"file":"Destroyable.js","sourceRoot":"","sources":["Destroyable.ts"],"names":[],"mappings":";;;;;;;;;;;IACA,8CAAyC;IAEzC;;OAEG;IACH;QACC,MAAM,CAAC,iBAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC/B,CAAC;IAAA,CAAC;IAEF;;OAEG;IACH;QACC,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;IAClD,CAAC;IAAA,CAAC;IAEF;QAMC;;WAEG;QACH;YACC,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;QACnB,CAAC;QAED;;;;;WAKG;QACH,yBAAG,GAAH,UAAI,MAAc;YACT,IAAA,sBAAO,CAAU;YACzB,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrB,MAAM,CAAC;gBACN,OAAO;oBACN,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;oBACxC,MAAM,CAAC,OAAO,EAAE,CAAC;gBAClB,CAAC;aACD,CAAC;QACH,CAAC;QAED;;;;WAIG;QACH,6BAAO,GAAP;YAAA,iBASC;YARA,MAAM,CAAC,IAAI,iBAAO,CAAC,UAAC,OAAO;gBAC1B,KAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAC,MAAM;oBAC3B,MAAM,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;gBAC9C,CAAC,CAAC,CAAC;gBACH,KAAI,CAAC,OAAO,GAAG,IAAI,CAAC;gBACpB,KAAI,CAAC,GAAG,GAAG,SAAS,CAAC;gBACrB,OAAO,CAAC,IAAI,CAAC,CAAC;YACf,CAAC,CAAC,CAAC;QACJ,CAAC;QACF,kBAAC;IAAD,CAAC,AA7CD,IA6CC;IA7CY,kCAAW;IA+CxB,kBAAe,WAAW,CAAC","sourcesContent":["import { Handle } from '@dojo/interfaces/core';\nimport Promise from '@dojo/shim/Promise';\n\n/**\n * No operation function to replace own once instance is destoryed\n */\nfunction noop(): Promise<boolean> {\n\treturn Promise.resolve(false);\n};\n\n/**\n * No op function used to replace own, once instance has been destoryed\n */\nfunction destroyed(): never {\n\tthrow new Error('Call made to destroyed method');\n};\n\nexport class Destroyable {\n\t/**\n\t * register handles for the instance\n\t */\n\tprivate handles: Handle[];\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\tthis.handles = [];\n\t}\n\n\t/**\n\t * Register handles for the instance that will be destroyed when `this.destroy` is called\n\t *\n\t * @param {Handle} handle The handle to add for the instance\n\t * @returns {Handle} a handle for the handle, removes the handle for the instance and calls destroy\n\t */\n\town(handle: Handle): Handle {\n\t\tconst { handles } = this;\n\t\thandles.push(handle);\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\thandles.splice(handles.indexOf(handle));\n\t\t\t\thandle.destroy();\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Destrpys all handers registered for the instance\n\t *\n\t * @returns {Promise<any} a promise that resolves once all handles have been destroyed\n\t */\n\tdestroy(): Promise<any> {\n\t\treturn new Promise((resolve) => {\n\t\t\tthis.handles.forEach((handle) => {\n\t\t\t\thandle && handle.destroy && handle.destroy();\n\t\t\t});\n\t\t\tthis.destroy = noop;\n\t\t\tthis.own = destroyed;\n\t\t\tresolve(true);\n\t\t});\n\t}\n}\n\nexport default Destroyable;\n"]}