{"version":3,"file":"aspect.js","sourceRoot":"","sources":["aspect.ts"],"names":[],"mappings":"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","sourcesContent":["import { Handle } from '@dojo/interfaces/core';\nimport WeakMap from '@dojo/shim/WeakMap';\nimport { createHandle } from './lang';\n\n/**\n * An object that provides the necessary APIs to be MapLike\n */\nexport interface MapLike<K, V> {\n\tget(key: K): V;\n\tset(key: K, value?: V): this;\n}\n\n/**\n * An internal type guard that determines if an value is MapLike or not\n *\n * @param value The value to guard against\n */\nfunction isMapLike(value: any): value is MapLike<any, any> {\n\treturn value && typeof value.get === 'function' && typeof value.set === 'function';\n}\n\nexport interface Indexable {\n\t[method: string]: any;\n}\n\n/**\n * The types of objects or maps where advice can be applied\n */\nexport type Targetable = MapLike<string, any> | Indexable;\n\ntype AdviceType = 'before' | 'after' | 'around';\n\n/**\n * A meta data structure when applying advice\n */\ninterface Advised {\n\treadonly id?: number;\n\tadvice?: Function;\n\tprevious?: Advised;\n\tnext?: Advised;\n\treadonly receiveArguments?: boolean;\n}\n\n/**\n * A function that dispatches advice which is decorated with additional\n * meta data about the advice to apply\n */\ninterface Dispatcher {\n\t[ type: string ]: Advised | undefined;\n\t(): any;\n\ttarget: any;\n\tbefore?: Advised;\n\taround?: Advised;\n\tafter?: Advised;\n}\n\nexport interface JoinPointDispatchAdvice<T> {\n\tbefore?: JoinPointBeforeAdvice[];\n\tafter?: JoinPointAfterAdvice<T>[];\n\treadonly joinPoint: Function;\n}\n\nexport interface JoinPointAfterAdvice<T> {\n\t/**\n\t * Advice which is applied *after*, receiving the result and arguments from the join point.\n\t *\n\t * @param result The result from the function being advised\n\t * @param args The arguments that were supplied to the advised function\n\t * @returns The value returned from the advice is then the result of calling the method\n\t */\n\t(result: T, ...args: any[]): T;\n}\n\nexport interface JoinPointAroundAdvice<T> {\n\t/**\n\t * Advice which is applied *around*.  The advising function receives the original function and\n\t * needs to return a new function which will then invoke the original function.\n\t *\n\t * @param origFn The original function\n\t * @returns A new function which will invoke the original function.\n\t */\n\t(origFn: GenericFunction<T>): (...args: any[]) => T;\n}\n\nexport interface JoinPointBeforeAdvice {\n\t/**\n\t * Advice which is applied *before*, receiving the original arguments, if the advising\n\t * function returns a value, it is passed further along taking the place of the original\n\t * arguments.\n\t *\n\t * @param args The arguments the method was called with\n\t */\n\t(...args: any[]): any[] | void;\n}\n\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\n/**\n * A weak map of dispatchers used to apply the advice\n */\nconst dispatchAdviceMap = new WeakMap<Function, JoinPointDispatchAdvice<any>>();\n\n/**\n * A UID for tracking advice ordering\n */\nlet nextId = 0;\n\n/**\n * Internal function that advises a join point\n *\n * @param dispatcher The current advice dispatcher\n * @param type The type of before or after advice to apply\n * @param advice The advice to apply\n * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n * @return The handle that will remove the advice\n */\nfunction adviseObject(\n\tdispatcher: Dispatcher | undefined,\n\ttype: AdviceType,\n\tadvice: Function | undefined,\n\treceiveArguments?: boolean\n): Handle {\n\tlet previous = dispatcher && dispatcher[type];\n\tlet advised: Advised | undefined = {\n\t\tid: nextId++,\n\t\tadvice: advice,\n\t\treceiveArguments: receiveArguments\n\t};\n\n\tif (previous) {\n\t\tif (type === 'after') {\n\t\t\t// add the listener to the end of the list\n\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t\t\twhile (previous.next && (previous = previous.next)) {}\n\t\t\tprevious.next = advised;\n\t\t\tadvised.previous = previous;\n\t\t}\n\t\telse {\n\t\t\t// add to the beginning\n\t\t\tif (dispatcher) {\n\t\t\t\tdispatcher.before = advised;\n\t\t\t}\n\t\t\tadvised.next = previous;\n\t\t\tprevious.previous = advised;\n\t\t}\n\t}\n\telse {\n\t\tdispatcher && (dispatcher[type] = advised);\n\t}\n\n\tadvice = previous = undefined;\n\n\treturn createHandle(function () {\n\t\tlet { previous = undefined, next = undefined } = (advised || {});\n\n\t\tif (dispatcher && !previous && !next) {\n\t\t\tdispatcher[type] = undefined;\n\t\t}\n\t\telse {\n\t\t\tif (previous) {\n\t\t\t\tprevious.next = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdispatcher && (dispatcher[type] = next);\n\t\t\t}\n\n\t\t\tif (next) {\n\t\t\t\tnext.previous = previous;\n\t\t\t}\n\t\t}\n\t\tif (advised) {\n\t\t\tdelete advised.advice;\n\t\t}\n\t\tdispatcher = advised = undefined;\n\t});\n}\n\n/**\n * Advise a join point (function) with supplied advice\n *\n * @param joinPoint The function to be advised\n * @param type The type of advice to be applied\n * @param advice The advice to apply\n */\nfunction adviseJoinPoint<F extends GenericFunction<T>, T>(this: any, joinPoint: F, type: AdviceType, advice: JoinPointBeforeAdvice | JoinPointAfterAdvice<T> | JoinPointAroundAdvice<T>): F {\n\tlet dispatcher: F;\n\tif (type === 'around') {\n\t\tdispatcher = getJoinPointDispatcher(advice.apply(this, [ joinPoint ]));\n\t}\n\telse {\n\t\tdispatcher = getJoinPointDispatcher(joinPoint);\n\t\t// cannot have undefined in map due to code logic, using !\n\t\tconst adviceMap = dispatchAdviceMap.get(dispatcher)!;\n\t\tif (type === 'before') {\n\t\t\t(adviceMap.before || (adviceMap.before = [])).unshift(<JoinPointBeforeAdvice> advice);\n\t\t}\n\t\telse {\n\t\t\t(adviceMap.after || (adviceMap.after = [])).push(advice);\n\t\t}\n\t}\n\treturn dispatcher;\n}\n\n/**\n * An internal function that resolves or creates the dispatcher for a given join point\n *\n * @param target The target object or map\n * @param methodName The name of the method that the dispatcher should be resolved for\n * @return The dispatcher\n */\nfunction getDispatcherObject(target: Targetable, methodName: string): Dispatcher {\n\tconst existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n\tlet dispatcher: Dispatcher;\n\n\tif (!existing || existing.target !== target) {\n\t\t/* There is no existing dispatcher, therefore we will create one */\n\t\tdispatcher = <Dispatcher> function (this: Dispatcher): any {\n\t\t\tlet executionId = nextId;\n\t\t\tlet args = arguments;\n\t\t\tlet results: any;\n\t\t\tlet before = dispatcher.before;\n\n\t\t\twhile (before) {\n\t\t\t\tif (before.advice) {\n\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t}\n\t\t\t\tbefore = before.next;\n\t\t\t}\n\n\t\t\tif (dispatcher.around && dispatcher.around.advice) {\n\t\t\t\tresults = dispatcher.around.advice(this, args);\n\t\t\t}\n\n\t\t\tlet after = dispatcher.after;\n\t\t\twhile (after && after.id !== undefined && after.id < executionId) {\n\t\t\t\tif (after.advice) {\n\t\t\t\t\tif (after.receiveArguments) {\n\t\t\t\t\t\tlet newResults = after.advice.apply(this, args);\n\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults = after.advice.call(this, results, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tafter = after.next;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\n\t\tif (isMapLike(target)) {\n\t\t\ttarget.set(methodName, dispatcher);\n\t\t}\n\t\telse {\n\t\t\ttarget && (target[methodName] = dispatcher);\n\t\t}\n\n\t\tif (existing) {\n\t\t\tdispatcher.around = {\n\t\t\t\tadvice: function (target: any, args: any[]): any {\n\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tdispatcher.target = target;\n\t}\n\telse {\n\t\tdispatcher = existing;\n\t}\n\n\treturn dispatcher;\n}\n\n/**\n * Returns the dispatcher function for a given joinPoint (method/function)\n *\n * @param joinPoint The function that is to be advised\n */\nfunction getJoinPointDispatcher<F extends GenericFunction<T>, T>(joinPoint: F): F {\n\n\tfunction dispatcher(this: Function, ...args: any[]): T {\n\t\t// cannot have undefined in map due to code logic, using !\n\t\tconst { before, after, joinPoint } = dispatchAdviceMap.get(dispatcher)!;\n\t\tif (before) {\n\t\t\targs = before.reduce((previousArgs, advice) => {\n\t\t\t\tconst currentArgs = advice.apply(this, previousArgs);\n\t\t\t\treturn currentArgs || previousArgs;\n\t\t\t}, args);\n\t\t}\n\t\tlet result = joinPoint.apply(this, args);\n\t\tif (after) {\n\t\t\tresult = after.reduce((previousResult, advice) => {\n\t\t\t\treturn advice.apply(this, [ previousResult ].concat(args));\n\t\t\t}, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* We want to \"clone\" the advice that has been applied already, if this\n\t * joinPoint is already advised */\n\tif (dispatchAdviceMap.has(joinPoint)) {\n\t\t// cannot have undefined in map due to code logic, using !\n\t\tconst adviceMap = dispatchAdviceMap.get(joinPoint)!;\n\t\tlet { before, after } = adviceMap;\n\t\tif (before) {\n\t\t\tbefore = before.slice(0);\n\t\t}\n\t\tif (after) {\n\t\t\tafter = after.slice(0);\n\t\t}\n\t\tdispatchAdviceMap.set(dispatcher, {\n\t\t\tjoinPoint: adviceMap.joinPoint,\n\t\t\tbefore,\n\t\t\tafter\n\t\t});\n\t}\n\t/* Otherwise, this is a new joinPoint, so we will create the advice map afresh */\n\telse {\n\t\tdispatchAdviceMap.set(dispatcher, { joinPoint });\n\t}\n\n\treturn dispatcher as F;\n}\n\n/**\n * Apply advice *after* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The after advice\n */\nfunction afterJoinPoint<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAfterAdvice<T>): F {\n\treturn adviseJoinPoint(joinPoint, 'after', advice);\n}\n\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nfunction afterObject(target: Targetable, methodName: string, advice: (originalReturn: any, originalArgs: IArguments) => any): Handle {\n\treturn adviseObject(getDispatcherObject(target, methodName), 'after', advice);\n}\n\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function after(target: Targetable, methodName: string, advice: (originalReturn: any, originalArgs: IArguments) => any): Handle;\n/**\n * Apply advice *after* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The after advice\n */\nexport function after<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAfterAdvice<T>): F;\nexport function after<F extends GenericFunction<T>, T>(joinPointOrTarget: F | Targetable, methodNameOrAdvice: string | JoinPointAfterAdvice<T>, objectAdvice?: (originalReturn: any, originalArgs: IArguments) => any): Handle | F {\n\tif (typeof joinPointOrTarget === 'function') {\n\t\treturn afterJoinPoint(joinPointOrTarget, <JoinPointAfterAdvice<T>> methodNameOrAdvice);\n\t}\n\telse {\n\t\treturn afterObject(joinPointOrTarget, <string> methodNameOrAdvice, objectAdvice!);\n\t}\n}\n\n/**\n * Apply advice *around* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nexport function aroundJoinPoint<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAroundAdvice<T>): F {\n\treturn adviseJoinPoint<F, T>(joinPoint, 'around', advice);\n}\n\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function aroundObject(target: Targetable, methodName: string, advice: ((previous: Function) => Function)): Handle {\n\tlet dispatcher: Dispatcher | undefined = getDispatcherObject(target, methodName);\n\tlet previous = dispatcher.around;\n\tlet advised: Function | undefined;\n\tif (advice) {\n\t\tadvised = advice(function (this: Dispatcher): any {\n\t\t\tif (previous && previous.advice) {\n\t\t\t\treturn previous.advice(this, arguments);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispatcher.around = {\n\t\tadvice: function (target: any, args: any[]): any {\n\t\t\treturn advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n\t\t}\n\t};\n\n\treturn createHandle(function () {\n\t\tadvised = dispatcher = undefined;\n\t});\n}\n\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function around(target: Targetable, methodName: string, advice: ((previous: Function) => Function)): Handle;\n/**\n * Apply advice *around* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nexport function around<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAroundAdvice<T>): F;\nexport function around<F extends GenericFunction<T>, T>(joinPointOrTarget: F | Targetable, methodNameOrAdvice: string | JoinPointAroundAdvice<T>, objectAdvice?: ((previous: Function) => Function)): Handle | F {\n\tif (typeof joinPointOrTarget === 'function') {\n\t\treturn aroundJoinPoint(joinPointOrTarget, <JoinPointAroundAdvice<T>> methodNameOrAdvice);\n\t}\n\telse {\n\t\treturn aroundObject(joinPointOrTarget, <string> methodNameOrAdvice, objectAdvice!);\n\t}\n}\n\n/**\n * Apply advice *before* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nexport function beforeJoinPoint<F extends GenericFunction<any>>(joinPoint: F, advice: JoinPointBeforeAdvice): F {\n\treturn adviseJoinPoint(joinPoint, 'before', advice);\n}\n\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function beforeObject(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any[] | void): Handle {\n\treturn adviseObject(getDispatcherObject(target, methodName), 'before', advice);\n}\n\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function before(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any[] | void): Handle;\n/**\n * Apply advice *before* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nexport function before<F extends GenericFunction<any>>(joinPoint: F, advice: JoinPointBeforeAdvice): F;\nexport function before<F extends GenericFunction<T>, T>(joinPointOrTarget: F | Targetable, methodNameOrAdvice: string | JoinPointBeforeAdvice, objectAdvice?: ((...originalArgs: any[]) => any[] | void)): Handle | F {\n\tif (typeof joinPointOrTarget === 'function') {\n\t\treturn beforeJoinPoint(joinPointOrTarget, <JoinPointBeforeAdvice> methodNameOrAdvice);\n\t}\n\telse {\n\t\treturn beforeObject(joinPointOrTarget, <string> methodNameOrAdvice, objectAdvice!);\n\t}\n}\n\n/**\n * Attaches advice to be executed after the original method.\n * The advising function will receive the same arguments as the original method.\n * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original method\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function on(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any): Handle {\n\treturn adviseObject(getDispatcherObject(target, methodName), 'after', advice, true);\n}\n"]}