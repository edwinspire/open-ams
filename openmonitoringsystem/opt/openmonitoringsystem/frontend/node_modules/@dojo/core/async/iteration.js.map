{"version":3,"file":"iteration.js","sourceRoot":"","sources":["iteration.ts"],"names":[],"mappings":"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","sourcesContent":["import * as array from '@dojo/shim/array';\nimport { isArrayLike, Iterable } from '@dojo/shim/iterator';\nimport Promise from '@dojo/shim/Promise';\nimport { Thenable } from '@dojo/shim/interfaces';\n\nfunction isThenable<T>(value: any): value is Thenable<T> {\n\treturn value && typeof value.then === 'function';\n}\n\ntype ValuesAndResults<T, U> = { values: T[] | undefined; results: U[] | undefined; };\n\n/**\n * Processes all items and then applies the callback to each item and eventually returns an object containing the\n * processed values and callback results\n * @param items a list of synchronous/asynchronous values to process\n * @param callback a callback that maps values to synchronous/asynchronous results\n * @return a list of objects holding the synchronous values and synchronous results.\n */\nfunction processValuesAndCallback<T, U>(items: Iterable<T | Promise<T>> | (T | Thenable<T>)[], callback: Mapper<T, U>): Promise<ValuesAndResults<T, U>> {\n\treturn Promise.all(items)\n\t\t.then(function (results) {\n\t\t\tconst pass: (U | Promise<U>)[] = Array.prototype.map.call(results, callback);\n\t\t\treturn Promise.all(pass)\n\t\t\t\t.then(function (pass) {\n\t\t\t\t\treturn { values: results, results: pass };\n\t\t\t\t});\n\t\t});\n}\n\n/**\n * Finds the index of the next value in a sparse array-like object\n * @param list the sparse array-like object\n * @param offset the starting offset\n * @return the offset of the next index with a value; or -1 if not found\n */\nfunction findNextValueIndex<T>(list: ArrayLike<T>, offset: number = -1): number {\n\toffset++;\n\tfor (let length = list.length; offset < length; offset++) {\n\t\tif (offset in list) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction findLastValueIndex(list: ArrayLike<any>, offset?: number): number {\n\toffset = (offset === undefined ? list.length : offset) - 1;\n\tfor (; offset >= 0; offset--) {\n\t\tif (offset in list) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction generalReduce<T, U>(findNextIndex: (list: ArrayLike<any> | undefined, offset?: number) => number, items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Reducer<T, U>, initialValue?: U): Promise<U> {\n\tconst hasInitialValue = arguments.length > 3;\n\treturn Promise.all(items)\n\t\t.then(function (results) {\n\t\t\treturn new Promise<U>(function (resolve, reject) {\n\t\t\t\t// As iterators do not have indices like `ArrayLike` objects, the results array\n\t\t\t\t// is used to determine the next value.\n\t\t\t\tconst list = isArrayLike(items) ? items : results;\n\t\t\t\tlet i: number;\n\t\t\t\tfunction next(currentValue: U | undefined): void {\n\t\t\t\t\ti = findNextIndex(list, i);\n\t\t\t\t\tif (i >= 0) {\n\t\t\t\t\t\tif (results) {\n\t\t\t\t\t\t\tif (currentValue) {\n\t\t\t\t\t\t\t\tconst result = callback(currentValue, results[i], i, results);\n\n\t\t\t\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\t\t\t\tresult.then(next, reject);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tnext(result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresolve(currentValue);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlet value: U | undefined;\n\t\t\t\tif (hasInitialValue) {\n\t\t\t\t\tvalue = initialValue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti = findNextIndex(list);\n\n\t\t\t\t\tif (i < 0) {\n\t\t\t\t\t\tthrow new Error('reduce array with no initial value');\n\t\t\t\t\t}\n\t\t\t\t\tif (results) {\n\t\t\t\t\t\tvalue = <any> results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext(value);\n\t\t\t});\n\t\t});\n}\n\nfunction testAndHaltOnCondition<T>(condition: boolean, items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<boolean> {\n\treturn Promise.all(items).then(function (results) {\n\t\treturn new Promise<boolean>(function(resolve) {\n\t\t\tlet result: (boolean | Thenable<boolean>);\n\t\t\tlet pendingCount = 0;\n\t\t\tif (results) {\n\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\tresult = callback(results[i], i, results);\n\t\t\t\t\tif (result === condition) {\n\t\t\t\t\t\treturn resolve(result);\n\t\t\t\t\t}\n\t\t\t\t\telse if (isThenable(result)) {\n\t\t\t\t\t\tpendingCount++;\n\t\t\t\t\t\tresult.then(function (result) {\n\t\t\t\t\t\t\tif (result === condition) {\n\t\t\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpendingCount--;\n\t\t\t\t\t\t\tif (pendingCount === 0) {\n\t\t\t\t\t\t\t\tresolve(!condition);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pendingCount === 0) {\n\t\t\t\tresolve(!condition);\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Test whether all elements in the array pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns true if all values pass; otherwise false\n */\nexport function every<T>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<boolean> {\n\treturn testAndHaltOnCondition(false, items, callback);\n}\n\n/**\n * Returns an array of elements which pass the provided callback\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return eventually returns a new array with only values that have passed\n */\nexport function filter<T>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<T[]> {\n\treturn processValuesAndCallback(items, callback).then(function (result) {\n\t\tlet arr: T[] = [];\n\t\tif (result && result.results && result.values) {\n\t\t\tfor (let i = 0; i < result.results.length; i++) {\n\t\t\t\tresult.results[i] && arr.push(result.values[i]);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t});\n}\n\n/**\n * Find the first value matching a filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the item or undefined if a match is not found\n */\nexport function find<T>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Filterer<T>): Promise<T | undefined> {\n\tconst list = isArrayLike(items) ? items : array.from(items);\n\treturn findIndex(list, callback).then<T | undefined>(function (i) {\n\t\treturn i !== undefined && i >= 0 ? list[i] : undefined;\n\t});\n}\n\n/**\n * Find the first index with a value matching the filter function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous test\n * @return a promise eventually containing the index of the matching item or -1 if a match is not found\n */\nexport function findIndex<T>(items: Iterable<T | Promise<T>> | (T | Thenable<T>)[], callback: Filterer<T>): Promise<number> {\n\t// TODO we can improve this by returning immediately\n\treturn processValuesAndCallback(items, callback).then(function (result: ValuesAndResults<T, boolean>) {\n\t\tif (result && result.results) {\n\t\t\tfor (let i = 0; i < result.results.length; i++) {\n\t\t\t\tif (result.results[i]) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t});\n}\n\n/**\n * transform a list of items using a mapper function\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous transform function\n * @return a promise eventually containing a collection of each transformed value\n */\nexport function map<T, U>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Mapper<T, U>): Promise<U[] | null | undefined> {\n\treturn processValuesAndCallback(items, callback)\n\t\t\t.then(function (result) {\n\t\t\t\treturn result ? result.results : null;\n\t\t\t});\n}\n\n/**\n * reduce a list of items down to a single value\n * @param items a collection of synchronous/asynchronous values\n * @param callback a synchronous/asynchronous reducer function\n * @param [initialValue] the first value to pass to the callback\n * @return a promise eventually containing a value that is the result of the reduction\n */\nexport function reduce<T, U>(this: any, items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Reducer<T, U>, initialValue?: U): Promise<U> {\n\tconst args: any[] = <any[]> array.from(arguments);\n\targs.unshift(findNextValueIndex);\n\treturn generalReduce.apply(this, args);\n}\n\nexport function reduceRight<T, U>(this: any, items: Iterable<T | Promise<T>> | (T | Promise<T>)[], callback: Reducer<T, U>, initialValue?: U): Promise<U> {\n\tconst args: any[] = <any[]> array.from(arguments);\n\targs.unshift(findLastValueIndex);\n\treturn generalReduce.apply(this, args);\n}\n\nexport function series<T, U>(items: Iterable<T | Promise<T>> | (T | Promise<T>)[], operation: Mapper<T, U>): Promise<U[]> {\n\treturn generalReduce(findNextValueIndex, items, function (previousValue, currentValue: T, index: number, array: T[]) {\n\t\tconst result = operation(currentValue, index, array);\n\n\t\tif (isThenable(result)) {\n\t\t\treturn result.then(function (value) {\n\t\t\t\tpreviousValue.push(value);\n\t\t\t\treturn previousValue;\n\t\t\t});\n\t\t}\n\n\t\tpreviousValue.push(result);\n\t\treturn previousValue;\n\t}, [] as U[]);\n}\n\nexport function some<T>(items: Iterable<T | Promise<T>> | Array<T | Promise<T>>, callback: Filterer<T>): Promise<boolean> {\n\treturn testAndHaltOnCondition(true, items, callback);\n}\n\nexport interface Filterer<T> extends Mapper<T, boolean> {}\n\nexport interface Mapper<T, U> {\n\t(value: T, index: number, array: T[]): (U | Thenable<U>);\n}\n\nexport interface Reducer<T, U> {\n\t(previousValue: U, currentValue: T, index: number, array: T[]): (U | Thenable<U>);\n}\n"]}