{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../src/lib/browser/util.ts"],"names":[],"mappings":"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","sourcesContent":["import request from '@dojo/core/request/providers/xhr';\nimport Task from '@dojo/core/async/Task';\nimport global from '@dojo/shim/global';\n\nimport {\n\tgetBasePath,\n\tloadConfig,\n\tparseArgs,\n\tsplitConfigPath\n} from '../common/util';\n\n/**\n * Resolve the user-supplied config data, which may include query args and a\n * config file.\n */\nexport function getConfig(file?: string) {\n\tconst args = parseArgs(parseQuery());\n\tconst configBase = getDefaultBasePath();\n\tif (file) {\n\t\targs.config = file;\n\t}\n\n\tlet load: Task<{ [key: string]: any }>;\n\n\tif (args.config) {\n\t\t// If a config parameter was provided, load it, mix in any other query\n\t\t// params, then initialize the executor with that\n\t\tconst { configFile, childConfig } = splitConfigPath(args.config);\n\t\tfile = resolvePath(configFile || 'intern.json', configBase);\n\t\tload = loadConfig(file, loadText, args, childConfig);\n\t} else {\n\t\t// If no config parameter was provided, try 'intern.json'. If that file\n\t\t// doesn't exist, just return the args\n\t\tfile = resolvePath('intern.json', configBase);\n\t\tload = loadConfig(file, loadText, args).catch(error => {\n\t\t\tif (error.message.indexOf('Request failed') === 0) {\n\t\t\t\t// The file wasn't found, clear the file name\n\t\t\t\tfile = undefined;\n\t\t\t\treturn args;\n\t\t\t}\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\treturn load\n\t\t.then(config => {\n\t\t\t// If a basePath wasn't set in the config or via a query arg, and we\n\t\t\t// have a config file path, use that.\n\t\t\tif (file) {\n\t\t\t\tconfig.basePath = getBasePath(\n\t\t\t\t\tfile,\n\t\t\t\t\tconfig.basePath,\n\t\t\t\t\tpath => path[0] === '/',\n\t\t\t\t\t'/'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn config;\n\t\t})\n\t\t.then(config => ({ config, file }));\n}\n\n/**\n * Return a base path based on the current location pathname\n */\nexport function getDefaultBasePath() {\n\tconst match = /^(.*\\/)node_modules\\/intern\\/?/.exec(\n\t\tglobal.location.pathname\n\t);\n\tif (match) {\n\t\t// If the current location contains `node_modules/intern`,\n\t\t// assume the base path is the parent of\n\t\t// `node_modules/intern`\n\t\treturn match[1];\n\t} else {\n\t\treturn '/';\n\t}\n}\n\n/**\n * Normalize a path (e.g., resolve '..')\n */\nexport function normalizePath(path: string) {\n\tconst parts = path.replace(/\\\\/g, '/').split('/');\n\tlet result: string[] = [];\n\tfor (let i = 0; i < parts.length; ++i) {\n\t\tlet part = parts[i];\n\n\t\tif (!part || part === '.') {\n\t\t\tif (i === 0 || i === parts.length - 1) {\n\t\t\t\tresult.push('');\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (part === '..') {\n\t\t\tif (result.length && result[result.length - 1] !== '..') {\n\t\t\t\tresult.pop();\n\t\t\t} else {\n\t\t\t\tresult.push(part);\n\t\t\t}\n\t\t} else {\n\t\t\tresult.push(part);\n\t\t}\n\t}\n\n\treturn result.join('/');\n}\n\n/**\n * Parse a query string and return a set of decoded name=value pairs\n */\nexport function parseQuery(query?: string) {\n\tquery = query || location.search.slice(1);\n\treturn query\n\t\t.split('&')\n\t\t.filter(arg => {\n\t\t\treturn arg !== '' && arg[0] !== '=';\n\t\t})\n\t\t.map(arg => {\n\t\t\tconst parts = arg.split('=');\n\t\t\tconst name = decodeURIComponent(parts[0]);\n\t\t\tif (parts[1]) {\n\t\t\t\treturn `${name}=${decodeURIComponent(parts[1])}`;\n\t\t\t} else if (parts.length > 1) {\n\t\t\t\treturn `${name}=`;\n\t\t\t}\n\t\t\treturn name;\n\t\t});\n}\n\n/**\n * Parse a URL\n */\nexport type Url = {\n\tprotocol: string;\n\thostname: string;\n\tport: string;\n\tpath: string;\n\tquery: string;\n\thash: string;\n};\nexport function parseUrl(url: string): Url | undefined {\n\tif (url) {\n\t\tconst match = /^(([^:\\/?#]+):)?(\\/\\/(([^:\\/?#]*)(:(\\d+))?))?([^?#]*)(\\?([^#]*))?(#(.*))?/.exec(\n\t\t\turl\n\t\t);\n\t\tif (match) {\n\t\t\treturn {\n\t\t\t\tprotocol: match[2],\n\t\t\t\thostname: match[5],\n\t\t\t\tport: match[7],\n\t\t\t\tpath: match[8],\n\t\t\t\tquery: match[10],\n\t\t\t\thash: match[12]\n\t\t\t};\n\t\t}\n\t}\n}\n\n/**\n * Load a text resource\n */\nfunction loadText(path: string): Task<any> {\n\treturn request(path).then(response => {\n\t\tif (!response.ok) {\n\t\t\tthrow new Error('Request failed: ' + response.status);\n\t\t}\n\t\treturn response.text();\n\t});\n}\n\n/**\n * Resolve a path against a base path\n */\nfunction resolvePath(path: string, basePath: string) {\n\tif (path[0] === '/') {\n\t\treturn path;\n\t}\n\n\tconst pathParts = path.split('/');\n\tconst basePathParts = basePath.split('/');\n\n\tif (basePathParts[basePathParts.length - 1] === '') {\n\t\tbasePathParts.pop();\n\t}\n\n\tfor (const part of pathParts) {\n\t\tif (part === '..') {\n\t\t\tbasePathParts.pop();\n\t\t} else if (part !== '.') {\n\t\t\tbasePathParts.push(part);\n\t\t}\n\t}\n\n\treturn basePathParts.join('/');\n}\n"]}