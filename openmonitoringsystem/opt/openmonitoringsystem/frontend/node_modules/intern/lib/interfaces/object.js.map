{"version":3,"file":"object.js","sourceRoot":"","sources":["../../../../src/lib/interfaces/object.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * This is the object interface for registering suites. Typically it will be\n * accessed using [[lib/executors/Executor.Executor.getInterface]], like:\n *\n * ```js\n * const { registerSuite } = intern.getInterface('object');\n * ```\n *\n * It may also be imported as a module, like\n *\n * ```js\n * import { registerSuite } from 'intern/lib/interfaces/object';\n * ```\n *\n * Suites are described using objects. The object structure is a subset of suite\n * properties, specifically name, the lifecycle methods, and tests.\n *\n * ```js\n * registerSuite('foo', {\n *     before() {},\n *     afterEach() {},\n *     tests: {\n *         bar() {},\n *         baz() {}\n *     }\n * });\n * ```\n *\n * Tests may also describe sub-suites:\n *\n * ```js\n * registerSuite('foo', {\n *     tests: {\n *         fooStuff {\n *             tests: {\n *                 bar() {},\n *                 baz() {}\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Sub-suites don't need name properties, and may also omit the 'tests' nesting\n * if no lifecycle functions are in use. The rule is that if a 'tests' property\n * isn't in the sub-suite object, then every property is assumed to refer to a\n * test.\n *\n * ```js\n * registerSuite('foo', {\n *     fooStuff {\n *         bar() {},\n *         baz() {}\n *     }\n * });\n * ```\n */ /** */\nimport global from '@dojo/shim/global';\n\nimport Suite, { SuiteOptions, SuiteProperties } from '../Suite';\nimport Test, { TestFunction, isTestFunction } from '../Test';\nimport { Executor } from '../executors/Executor';\n\n/**\n * Importable interface that uses the currently installed global executor\n */\nexport default function registerSuite(\n\tname: string,\n\tdescriptorOrFactory: ObjectSuiteDescriptor | ObjectSuiteFactory | Tests\n) {\n\treturn _registerSuite(global.intern, name, descriptorOrFactory);\n}\n\n/**\n * Interface factory used by Executor\n */\nexport function getInterface(executor: Executor) {\n\treturn {\n\t\tregisterSuite(\n\t\t\tname: string,\n\t\t\tdescriptorOrFactory:\n\t\t\t\t| ObjectSuiteDescriptor\n\t\t\t\t| ObjectSuiteFactory\n\t\t\t\t| Tests\n\t\t) {\n\t\t\treturn _registerSuite(executor, name, descriptorOrFactory);\n\t\t}\n\t};\n}\n\nexport interface ObjectInterface {\n\tregisterSuite(\n\t\tname: string,\n\t\tmainDescriptor: ObjectSuiteDescriptor | ObjectSuiteFactory | Tests\n\t): void;\n}\n\nexport interface Tests {\n\t[name: string]: ObjectSuiteDescriptor | TestFunction | Tests;\n}\n\nexport interface ObjectSuiteDescriptor extends Partial<SuiteProperties> {\n\ttests: Tests;\n}\n\nexport interface ObjectSuiteFactory {\n\t(): ObjectSuiteDescriptor | Tests;\n}\n\nexport function isSuiteDescriptorFactory<T>(value: any): value is T {\n\treturn typeof value === 'function';\n}\n\nexport function createSuite<S extends typeof Suite, T extends typeof Test>(\n\tname: string,\n\tparent: Suite,\n\tdescriptor: ObjectSuiteDescriptor | Tests,\n\tSuiteClass: S,\n\tTestClass: T\n) {\n\tlet options: SuiteOptions = { name: name, parent };\n\tlet tests: Tests;\n\n\t// Initialize a new SuiteOptions object from the provided\n\t// ObjectSuiteDescriptor\n\tif (isObjectSuiteDescriptor(descriptor)) {\n\t\tconst keys = Object.keys(descriptor).filter(key => key !== 'tests');\n\t\tfor (const key of keys) {\n\t\t\tlet optionsKey = <keyof SuiteOptions>key;\n\n\t\t\t// Convert 'setup' and 'teardown' to 'before' and 'after'\n\t\t\tif (key === 'setup') {\n\t\t\t\tparent.executor.emit('deprecated', {\n\t\t\t\t\toriginal: 'Suite#setup',\n\t\t\t\t\treplacement: 'Suite#before'\n\t\t\t\t});\n\t\t\t\toptionsKey = 'before';\n\t\t\t} else if (key === 'teardown') {\n\t\t\t\tparent.executor.emit('deprecated', {\n\t\t\t\t\toriginal: 'Suite#teardown',\n\t\t\t\t\treplacement: 'Suite#after'\n\t\t\t\t});\n\t\t\t\toptionsKey = 'after';\n\t\t\t}\n\n\t\t\toptions[optionsKey] = <any>descriptor[\n\t\t\t\t<keyof ObjectSuiteDescriptor>key\n\t\t\t];\n\t\t}\n\n\t\ttests = descriptor.tests;\n\t} else {\n\t\ttests = descriptor;\n\t}\n\n\tconst suite = new SuiteClass(options);\n\n\tObject.keys(tests)\n\t\t.map(name => {\n\t\t\tif (\n\t\t\t\tname === 'before' ||\n\t\t\t\tname === 'after' ||\n\t\t\t\tname === 'setup' ||\n\t\t\t\tname === 'teardown' ||\n\t\t\t\tname === 'beforeEach' ||\n\t\t\t\tname === 'afterEach'\n\t\t\t) {\n\t\t\t\tparent.executor.log(\n\t\t\t\t\t`Warning: created test with lifecycle method name \"${name}\"`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst thing = tests[name];\n\t\t\tif (isTestFunction(thing)) {\n\t\t\t\treturn new TestClass({ name, test: thing, parent: suite });\n\t\t\t}\n\t\t\treturn createSuite(\n\t\t\t\tname,\n\t\t\t\tsuite,\n\t\t\t\t{ ...thing },\n\t\t\t\tSuiteClass,\n\t\t\t\tTestClass\n\t\t\t);\n\t\t})\n\t\t.forEach(suiteOrTest => {\n\t\t\tsuite.add(suiteOrTest);\n\t\t});\n\n\treturn suite;\n}\n\nfunction isObjectSuiteDescriptor(value: any): value is ObjectSuiteDescriptor {\n\treturn typeof value === 'object' && typeof value.tests === 'object';\n}\n\nfunction _registerSuite(\n\texecutor: Executor,\n\tname: string,\n\tdescriptorOrFactory: ObjectSuiteDescriptor | ObjectSuiteFactory | Tests\n) {\n\texecutor.addSuite(parent => {\n\t\t// Enable per-suite closure, to match feature parity with other\n\t\t// interfaces like tdd/bdd more closely; without this, it becomes\n\t\t// impossible to use the object interface for functional tests since\n\t\t// there is no other way to create a closure for each main suite\n\t\tlet descriptor: ObjectSuiteDescriptor | Tests;\n\n\t\tif (isSuiteDescriptorFactory<ObjectSuiteFactory>(descriptorOrFactory)) {\n\t\t\tdescriptor = descriptorOrFactory();\n\t\t} else {\n\t\t\tdescriptor = descriptorOrFactory;\n\t\t}\n\n\t\tparent.add(createSuite(name, parent, descriptor, Suite, Test));\n\t});\n}\n"]}