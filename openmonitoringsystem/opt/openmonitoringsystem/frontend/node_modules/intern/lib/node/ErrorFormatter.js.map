{"version":3,"file":"ErrorFormatter.js","sourceRoot":"","sources":["../../../../src/lib/node/ErrorFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["import { readFileSync } from 'fs';\nimport { dirname, join, relative, resolve } from 'path';\nimport { MappingItem, SourceMapConsumer } from 'source-map';\n\nimport ErrorFormatter from '../common/ErrorFormatter';\nimport { readSourceMap } from './util';\nimport Node from '../executors/Node';\n\nexport default class NodeErrorFormatter extends ErrorFormatter {\n\treadonly executor!: Node;\n\n\tprivate fileSourceMaps: { [path: string]: SourceMapConsumer } = {};\n\tprivate fileSources: { [path: string]: string } = {};\n\n\tconstructor(executor: Node) {\n\t\tsuper(executor);\n\t}\n\n\t/**\n\t * Dereference the source from a traceline.\n\t */\n\tprotected _getSource(tracepath: string) {\n\t\tif (tracepath === '<anonymous>') {\n\t\t\treturn 'anonymous';\n\t\t}\n\n\t\tlet sourcepath = this._getSourceHelper(tracepath);\n\t\twhile (sourcepath !== tracepath) {\n\t\t\ttracepath = sourcepath;\n\t\t\tsourcepath = this._getSourceHelper(tracepath);\n\t\t}\n\n\t\treturn tracepath;\n\t}\n\n\tprivate _getSourceHelper(tracepath: string) {\n\t\tlet match: RegExpMatchArray | null;\n\t\tlet source: string | undefined;\n\t\tlet line: number;\n\t\tlet col: number | undefined;\n\t\tlet map: SourceMapConsumer | undefined;\n\t\tlet originalPos: { source?: string; line: number; column?: number };\n\t\tlet result: string;\n\n\t\tif (!(match = /^(.*?):(\\d+)(:\\d+)?$/.exec(tracepath))) {\n\t\t\t// no line or column data\n\t\t\treturn tracepath;\n\t\t}\n\n\t\ttracepath = match[1];\n\t\tline = Number(match[2]);\n\t\tcol = match[3] ? Number(match[3].substring(1)) : undefined;\n\n\t\t// If the tracepath starts with the server URL, resolve it to something\n\t\t// local\n\t\tif (tracepath.indexOf(this.executor.config.serverUrl) === 0) {\n\t\t\ttracepath = tracepath.slice(this.executor.config.serverUrl.length);\n\t\t\ttracepath = tracepath.replace(\n\t\t\t\t/^__intern\\//,\n\t\t\t\tthis.executor.config.internPath\n\t\t\t);\n\t\t}\n\n\t\t// Make the tracepath absolute since that's how it will be stored in map\n\t\t// stores\n\t\ttracepath = resolve(tracepath);\n\n\t\tconst instrumentedStore = this.executor.instrumentedMapStore;\n\n\t\t// first, check for an instrumentation source map\n\t\tif (tracepath in instrumentedStore.data) {\n\t\t\tmap = new SourceMapConsumer(instrumentedStore.data[tracepath].data);\n\t\t\toriginalPos = this.getOriginalPosition(map, line, col);\n\t\t\tline = originalPos.line;\n\t\t\tcol = originalPos.column;\n\t\t\tif (originalPos.source) {\n\t\t\t\tsource = originalPos.source;\n\t\t\t}\n\t\t}\n\n\t\tsource = source || tracepath;\n\n\t\t// next, check for original source map\n\t\tconst sourceMapStore = this.executor.sourceMapStore;\n\t\tif (source in sourceMapStore.data) {\n\t\t\tmap = new SourceMapConsumer(sourceMapStore.data[source].data);\n\t\t} else {\n\t\t\tmap = this.getSourceMap(source);\n\t\t}\n\n\t\tsource = relative('.', source);\n\n\t\tif (map) {\n\t\t\toriginalPos = this.getOriginalPosition(map, line, col);\n\t\t\tline = originalPos.line;\n\t\t\tcol = originalPos.column;\n\t\t\tif (originalPos.source) {\n\t\t\t\t// If original source starts with ./ or ../, or is just a bare\n\t\t\t\t// filename, assume it's relative to the current source\n\t\t\t\tif (\n\t\t\t\t\toriginalPos.source.indexOf('/') === -1 ||\n\t\t\t\t\t/\\.\\.?\\//.test(originalPos.source)\n\t\t\t\t) {\n\t\t\t\t\tsource = join(dirname(source), originalPos.source);\n\t\t\t\t} else {\n\t\t\t\t\t// If not, assume its relative to the project root\n\t\t\t\t\tsource = originalPos.source;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Source should be relative, because that's what we want the user to\n\t\t// see\n\t\tsource = relative('.', source);\n\n\t\tresult = source + ':' + line;\n\t\tif (col !== null) {\n\t\t\tresult += ':' + col;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get the original position of line:column based on map.\n\t *\n\t * Assumes mappings are is in order by generatedLine, then by\n\t * generatedColumn; maps created with SourceMapConsumer.eachMapping should\n\t * be in this order by default.\n\t */\n\tprivate getOriginalPosition(\n\t\tmap: SourceMapConsumer,\n\t\tline: number,\n\t\tcolumn?: number\n\t): { line: number; column?: number; source?: string } {\n\t\tconst originalPosition = map.originalPositionFor({\n\t\t\tline: line,\n\t\t\tcolumn: column!\n\t\t});\n\n\t\t// if the SourceMapConsumer was able to find a location, return it\n\t\tif (originalPosition.line != null) {\n\t\t\treturn originalPosition;\n\t\t}\n\n\t\tconst entries: MappingItem[] = [];\n\n\t\t// find all map entries that apply to the given line in the generated\n\t\t// output\n\t\tmap.eachMapping(\n\t\t\tentry => {\n\t\t\t\tif (entry.generatedLine === line) {\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t}\n\t\t\t},\n\t\t\tnull,\n\t\t\tSourceMapConsumer.GENERATED_ORDER\n\t\t);\n\n\t\tif (entries.length === 0) {\n\t\t\t// no valid mappings exist -- return the line and column arguments\n\t\t\treturn { line: line, column: column };\n\t\t}\n\n\t\tlet position = entries[0];\n\n\t\t// Chrome/Node.js column is at the start of the term that generated the\n\t\t// exception IE column is at the beginning of the expression/line with\n\t\t// the exceptional term\n\t\t//\n\t\t// Safari column number is just after the exceptional term\n\t\t//   - need to go back one element in the mapping\n\t\t//\n\t\t// Firefox, PhantomJS have no column number\n\t\t//   - for no col number, find the largest original line number for the\n\t\t//     generated line\n\n\t\tif (column != null) {\n\t\t\t// find the most likely mapping for the given generated line and\n\t\t\t// column\n\t\t\tlet entry: MappingItem;\n\t\t\tfor (let i = 1; i < entries.length; i++) {\n\t\t\t\tentry = entries[i];\n\t\t\t\tif (\n\t\t\t\t\tcolumn > position.generatedColumn &&\n\t\t\t\t\tcolumn >= entry.generatedColumn\n\t\t\t\t) {\n\t\t\t\t\tposition = entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tline: position.originalLine,\n\t\t\tcolumn: position.originalColumn,\n\t\t\tsource: position.source\n\t\t};\n\t}\n\n\t/**\n\t * Load and process the source map for a given file.\n\t */\n\tprivate getSourceMap(filepath: string) {\n\t\tif (filepath in this.fileSourceMaps) {\n\t\t\treturn this.fileSourceMaps[filepath];\n\t\t}\n\n\t\ttry {\n\t\t\tlet data: string;\n\n\t\t\tif (filepath in this.fileSources) {\n\t\t\t\tdata = this.fileSources[filepath];\n\t\t\t} else {\n\t\t\t\tdata = readFileSync(filepath).toString('utf-8');\n\t\t\t\tthis.fileSources[filepath] = data;\n\t\t\t}\n\n\t\t\tconst rawMap = readSourceMap(filepath, data);\n\t\t\tif (rawMap) {\n\t\t\t\tthis.fileSourceMaps[filepath] = new SourceMapConsumer(rawMap);\n\t\t\t\treturn this.fileSourceMaps[filepath];\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// this is normal for files like node.js -- just return null\n\t\t}\n\t}\n}\n"]}