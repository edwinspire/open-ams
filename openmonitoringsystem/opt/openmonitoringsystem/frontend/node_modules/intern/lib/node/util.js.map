{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../src/lib/node/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { readFile, readFileSync } from 'fs';\nimport { dirname, isAbsolute, join, normalize, resolve, sep } from 'path';\nimport { parse } from 'shell-quote';\nimport { RawSourceMap } from 'source-map';\nimport { sync as glob, hasMagic } from 'glob';\n\nimport Task from '@dojo/core/async/Task';\nimport { mixin } from '@dojo/core/lang';\n\nimport process from './process';\nimport {\n\tgetBasePath,\n\tloadConfig,\n\tparseArgs,\n\tsplitConfigPath\n} from '../common/util';\n\n/**\n * Expand a list of glob patterns into a flat file list. Patterns may be simple\n * file paths or glob patterns. Patterns starting with '!' denote exclusions.\n * Note that exclusion rules will not apply to simple paths.\n */\nexport function expandFiles(patterns?: string[] | string) {\n\tif (!patterns) {\n\t\tpatterns = [];\n\t} else if (!Array.isArray(patterns)) {\n\t\tpatterns = [patterns];\n\t}\n\n\tconst excludes: string[] = [];\n\tconst includes: string[] = [];\n\tconst paths: string[] = [];\n\n\tfor (let pattern of patterns) {\n\t\tif (pattern[0] === '!') {\n\t\t\texcludes.push(pattern.slice(1));\n\t\t} else {\n\t\t\tif (hasMagic(pattern)) {\n\t\t\t\tincludes.push(pattern);\n\t\t\t} else {\n\t\t\t\tpaths.push(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst allPaths = includes\n\t\t.map(pattern => glob(pattern, { ignore: excludes }))\n\t\t.reduce((allFiles, files) => allFiles.concat(files), paths);\n\tconst uniquePaths: { [name: string]: boolean } = {};\n\tallPaths.forEach(path => (uniquePaths[path] = true));\n\n\treturn Object.keys(uniquePaths);\n}\n\n/**\n * Get the user-supplied config data, which may include command line args and a\n * config file.\n *\n * @param file A config file\n * @param argv An array of command line arguments. This should follow the same\n * format as process.argv (where user args start at index 2).\n */\nexport function getConfig(file?: string): Task<{ config: any; file?: string }>;\nexport function getConfig(\n\targv?: string[]\n): Task<{ config: any; file?: string }>;\nexport function getConfig(\n\tfile: string,\n\targv?: string[]\n): Task<{ config: any; file?: string }>;\nexport function getConfig(fileOrArgv?: string | string[], argv?: string[]) {\n\tlet args: { [key: string]: any } = {};\n\tlet file = typeof fileOrArgv === 'string' ? fileOrArgv : undefined;\n\targv = Array.isArray(fileOrArgv) ? fileOrArgv : argv;\n\tconst userArgs = (argv || process.argv).slice(2);\n\n\tif (process.env['INTERN_ARGS']) {\n\t\tmixin(args, parseArgs(parse(process.env['INTERN_ARGS'] || '')));\n\t}\n\n\tif (userArgs.length > 0) {\n\t\tmixin(args, parseArgs(userArgs));\n\t}\n\n\tif (file) {\n\t\targs.config = file;\n\t}\n\n\tlet load: Task<{ [key: string]: any }>;\n\n\tif (args.config) {\n\t\t// If a config parameter was provided, load it and mix in any other\n\t\t// command line args.\n\t\tconst { configFile, childConfig } = splitConfigPath(args.config, sep);\n\t\tfile = resolve(configFile || 'intern.json');\n\t\tload = loadConfig(file, loadText, args, childConfig);\n\t} else {\n\t\t// If no config parameter was provided, try 'intern.json', or just\n\t\t// resolve to the original args\n\t\tfile = resolve('intern.json');\n\t\tload = loadConfig(file, loadText, args, undefined).catch(\n\t\t\t(error: NodeJS.ErrnoException) => {\n\t\t\t\tif (error.code === 'ENOENT') {\n\t\t\t\t\tfile = undefined;\n\t\t\t\t\treturn args;\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\treturn load\n\t\t.then(config => {\n\t\t\t// If a basePath wasn't set in the config or via a query arg, and we\n\t\t\t// have a config file path, use that.\n\t\t\tif (file) {\n\t\t\t\tconfig.basePath = getBasePath(\n\t\t\t\t\tfile,\n\t\t\t\t\tconfig.basePath,\n\t\t\t\t\tisAbsolute,\n\t\t\t\t\tsep\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn config;\n\t\t})\n\t\t.then(config => ({ config, file }));\n}\n\n/**\n * Loads a text resource.\n */\nexport function loadText(path: string) {\n\treturn new Task<string>((resolve, reject) => {\n\t\treadFile(path, { encoding: 'utf8' }, (error, data) => {\n\t\t\tif (error) {\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tresolve(data);\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Normalize a path (e.g., resolve '..')\n */\nexport function normalizePath(path: string) {\n\treturn normalize(path).replace(/\\\\/g, '/');\n}\n\n/**\n * Given a source filename, and optionally code, return the file's source map if\n * one exists.\n */\nexport function readSourceMap(\n\tsourceFile: string,\n\tcode?: string\n): RawSourceMap | undefined {\n\tif (!code) {\n\t\tcode = readFileSync(sourceFile, { encoding: 'utf8' });\n\t}\n\n\tlet match: RegExpMatchArray | null;\n\n\t// sourceMappingUrl must be on last line of source file; search for last\n\t// newline from code.length - 2 in case the file ends with a newline\n\tconst lastNewline = code.lastIndexOf('\\n', code.length - 2);\n\tconst lastLine = code.slice(lastNewline + 1);\n\n\tif ((match = sourceMapRegEx.exec(lastLine))) {\n\t\tif (match[1]) {\n\t\t\treturn JSON.parse(new Buffer(match[2], 'base64').toString('utf8'));\n\t\t} else {\n\t\t\t// Treat map file path as relative to the source file\n\t\t\tconst mapFile = join(dirname(sourceFile), match[2]);\n\t\t\treturn JSON.parse(readFileSync(mapFile, { encoding: 'utf8' }));\n\t\t}\n\t}\n}\n\n// Regex for matching sourceMappingUrl comments\nconst sourceMapRegEx = /^(?:\\/{2}[#@]{1,2}|\\/\\*)\\s+sourceMappingURL\\s*=\\s*(data:(?:[^;]+;)+base64,)?(\\S+)/;\n"]}