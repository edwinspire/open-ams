{"version":3,"file":"Suite.js","sourceRoot":"","sources":["../../../src/lib/Suite.ts"],"names":[],"mappings":"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","sourcesContent":["import Task, { isThenable, State } from '@dojo/core/async/Task';\n\nimport { isTask } from './common/util';\nimport Deferred from './Deferred';\nimport { Executor } from './executors/Executor';\nimport Test, { isTest, SKIP } from './Test';\nimport { InternError } from './types';\nimport { Remote } from './executors/Node';\n\n/**\n * The Suite class manages a group of tests.\n */\nexport default class Suite implements SuiteProperties {\n\t/**\n\t * An optional method that is run after all the suite's tests have completed\n\t */\n\tafter: SuiteLifecycleFunction | undefined;\n\n\t/**\n\t * An optional method that is run after each test has completed\n\t */\n\tafterEach: TestLifecycleFunction | undefined;\n\n\t/**\n\t * A convenience function that generates and returns a special\n\t * [[lib/Deferred.Deferred]] that can be used for asynchronous testing\n\t */\n\tasync: ((timeout?: number) => Deferred<void>) | undefined;\n\n\t/**\n\t * An optional method that is run before any of this suite's tests are\n\t * started\n\t */\n\tbefore: SuiteLifecycleFunction | undefined;\n\n\t/**\n\t * An optional method that is run before each test\n\t */\n\tbeforeEach: TestLifecycleFunction | undefined;\n\n\t/** The error that caused this suite to fail */\n\terror: InternError | undefined;\n\n\t/** This suite's name */\n\tname: string | undefined;\n\n\t/** This suite's parent Suite */\n\tparent: Suite | undefined;\n\n\t/**\n\t * If true, the suite will emit a suiteStart event after the `before`\n\t * callback has finished, and will emit a suiteEnd event before the `after`\n\t * callback has finished.\n\t */\n\tpublishAfterSetup = false;\n\n\t/** The reason why this suite was skipped */\n\tskipped: string | undefined;\n\n\t/** The tests or other suites managed by this suite */\n\ttests: (Suite | Test)[];\n\n\t/** The time required to run all the tests in this suite */\n\ttimeElapsed: number | undefined;\n\n\tprivate _bail: boolean | undefined;\n\tprivate _executor: Executor | undefined;\n\tprivate _grep: RegExp | undefined;\n\tprivate _remote: Remote | undefined;\n\tprivate _sessionId: string | undefined;\n\tprivate _timeout: number | undefined;\n\n\t/**\n\t * @param options an object with default property values\n\t */\n\tconstructor(options: SuiteOptions | RootSuiteOptions) {\n\t\tObject.keys(options)\n\t\t\t.filter(key => {\n\t\t\t\treturn key !== 'tests';\n\t\t\t})\n\t\t\t.forEach(option => {\n\t\t\t\tconst key = <keyof (SuiteOptions | RootSuiteOptions)>option;\n\t\t\t\tthis[key] = options[key]!;\n\t\t\t});\n\n\t\tthis.tests = [];\n\n\t\tif (options.tests) {\n\t\t\toptions.tests.forEach(suiteOrTest => this.add(suiteOrTest));\n\t\t}\n\n\t\tif (!this.name && this.parent) {\n\t\t\tthrow new Error('A non-root Suite must have a name');\n\t\t}\n\t}\n\n\t/**\n\t * A flag used to indicate whether a test run should stop after a failed\n\t * test.\n\t */\n\tget bail() {\n\t\treturn this._bail || (this.parent && this.parent.bail)!;\n\t}\n\n\tset bail(value: boolean) {\n\t\tthis._bail = value;\n\t}\n\n\t/**\n\t * The executor used to run this Suite.\n\t */\n\tget executor(): Executor {\n\t\t// Prefer the parent's executor\n\t\treturn (this.parent && this.parent.executor) || this._executor!;\n\t}\n\n\tset executor(value: Executor) {\n\t\tif (this._executor) {\n\t\t\tconst error = new Error(\n\t\t\t\t'An executor may only be set once per suite'\n\t\t\t);\n\t\t\terror.name = 'AlreadyAssigned';\n\t\t\tthrow error;\n\t\t}\n\t\tthis._executor = value;\n\t}\n\n\t/**\n\t * A regular expression used to filter, by test ID, which tests are run.\n\t */\n\tget grep() {\n\t\treturn this._grep || (this.parent && this.parent.grep) || /.*/;\n\t}\n\n\tset grep(value: RegExp) {\n\t\tthis._grep = value;\n\t}\n\n\t/**\n\t * The unique identifier of the suite, assuming all combinations of suite +\n\t * test are unique.\n\t */\n\tget id() {\n\t\tlet name: string[] = [];\n\t\tlet suite: Suite = this;\n\n\t\tdo {\n\t\t\tsuite.name != null && name.unshift(suite.name);\n\t\t} while ((suite = suite.parent!));\n\n\t\treturn name.join(' - ');\n\t}\n\n\t/**\n\t * The unique identifier of the suite's parent.\n\t */\n\tget parentId() {\n\t\tconst parent = this.parent;\n\t\tif (parent) {\n\t\t\treturn parent.id;\n\t\t}\n\t}\n\n\t/**\n\t * The WebDriver interface for driving a remote environment. This value is\n\t * only guaranteed to exist from the before/beforeEach/afterEach/after and\n\t * test methods, since environments are not instantiated until they are\n\t * actually ready to be tested against.\n\t */\n\tget remote() {\n\t\treturn this.parent && this.parent.remote\n\t\t\t? this.parent.remote\n\t\t\t: this._remote!;\n\t}\n\n\tset remote(value: Remote) {\n\t\tif (this._remote) {\n\t\t\tthrow new Error(\n\t\t\t\t'AlreadyAssigned: remote may only be set once per suite'\n\t\t\t);\n\t\t}\n\t\tthis._remote = value;\n\t}\n\n\t/**\n\t * The sessionId of the environment in which the suite executed.\n\t */\n\tget sessionId(): string {\n\t\tif (this.parent) {\n\t\t\treturn this.parent.sessionId;\n\t\t}\n\t\tif (this._sessionId) {\n\t\t\treturn this._sessionId;\n\t\t}\n\t\tif (this.remote) {\n\t\t\treturn this.remote.session.sessionId;\n\t\t}\n\t\treturn '';\n\t}\n\n\tset sessionId(value: string) {\n\t\tthis._sessionId = value;\n\t}\n\n\t/**\n\t * The total number of tests in this suite and any sub-suites. To get only\n\t * the number of tests for this suite, look at `this.tests.length`.\n\t */\n\tget numTests(): number {\n\t\treturn this.tests.reduce((numTests, suiteOrTest) => {\n\t\t\tif (isSuite(suiteOrTest)) {\n\t\t\t\treturn numTests + suiteOrTest.numTests;\n\t\t\t}\n\t\t\treturn numTests + 1;\n\t\t}, 0);\n\t}\n\n\t/**\n\t * The total number of tests in this test suite that passed.\n\t */\n\tget numPassedTests(): number {\n\t\treturn this.tests.reduce((numPassedTests, suiteOrTest) => {\n\t\t\tif (isSuite(suiteOrTest)) {\n\t\t\t\treturn numPassedTests + suiteOrTest.numPassedTests;\n\t\t\t} else if (suiteOrTest.hasPassed) {\n\t\t\t\treturn numPassedTests + 1;\n\t\t\t}\n\t\t\treturn numPassedTests;\n\t\t}, 0);\n\t}\n\n\t/**\n\t * The total number of tests in this test suite and any sub-suites that\n\t * failed.\n\t */\n\tget numFailedTests(): number {\n\t\treturn this.tests.reduce((numFailedTests, suiteOrTest) => {\n\t\t\tif (isSuite(suiteOrTest)) {\n\t\t\t\treturn numFailedTests + suiteOrTest.numFailedTests;\n\t\t\t} else if (suiteOrTest.error) {\n\t\t\t\treturn numFailedTests + 1;\n\t\t\t}\n\t\t\treturn numFailedTests;\n\t\t}, 0);\n\t}\n\n\t/**\n\t * The total number of tests in this test suite and any sub-suites that were\n\t * skipped.\n\t */\n\tget numSkippedTests(): number {\n\t\treturn this.tests.reduce((numSkippedTests, suiteOrTest) => {\n\t\t\tif (isSuite(suiteOrTest)) {\n\t\t\t\treturn numSkippedTests + suiteOrTest.numSkippedTests;\n\t\t\t} else if (suiteOrTest.skipped) {\n\t\t\t\treturn numSkippedTests + 1;\n\t\t\t}\n\t\t\treturn numSkippedTests;\n\t\t}, 0);\n\t}\n\n\t/**\n\t * Whether or not this suite has a parent (for parity with serialized\n\t * Suites).\n\t */\n\tget hasParent() {\n\t\treturn Boolean(this.parent);\n\t}\n\n\tget timeout() {\n\t\tif (this._timeout != null) {\n\t\t\treturn this._timeout;\n\t\t}\n\t\tif (this.parent) {\n\t\t\treturn this.parent.timeout;\n\t\t}\n\t\treturn 30000;\n\t}\n\n\tset timeout(value: number) {\n\t\tthis._timeout = value;\n\t}\n\n\t/**\n\t * Add a test or suite to this suite.\n\t */\n\tadd(suiteOrTest: Suite | Test) {\n\t\tif (!isTest(suiteOrTest) && !isSuite(suiteOrTest)) {\n\t\t\tthrow new Error('Tried to add invalid suite or test');\n\t\t}\n\n\t\tif (suiteOrTest.parent != null && suiteOrTest.parent !== this) {\n\t\t\tthrow new Error(\n\t\t\t\t'This Suite or Test already belongs to another parent'\n\t\t\t);\n\t\t}\n\n\t\tthis.tests.forEach(existingSuiteOrTest => {\n\t\t\tif (existingSuiteOrTest.name === suiteOrTest.name) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`A suite or test named \"${\n\t\t\t\t\t\tsuiteOrTest.name\n\t\t\t\t\t}\" has already been added`\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tsuiteOrTest.parent = this;\n\t\tthis.tests.push(suiteOrTest);\n\n\t\tif (isTest(suiteOrTest)) {\n\t\t\tthis.executor.emit('testAdd', suiteOrTest);\n\t\t} else {\n\t\t\tthis.executor.emit('suiteAdd', suiteOrTest);\n\t\t}\n\t}\n\n\t/**\n\t * Runs test suite in order:\n\t *\n\t * * before\n\t * * (for each test)\n\t *   * beforeEach\n\t *   * test\n\t *   * afterEach\n\t * * after\n\t *\n\t * If before, beforeEach, afterEach, or after throw, the suite itself will\n\t * be marked as failed and no further tests in the suite will be executed.\n\t */\n\trun(): Task<void> {\n\t\tlet startTime: number;\n\n\t\t// Run when the suite starts\n\t\tconst start = () => {\n\t\t\treturn this.executor.emit('suiteStart', this).then(function() {\n\t\t\t\tstartTime = Date.now();\n\t\t\t});\n\t\t};\n\n\t\t// Run when the suite has ended\n\t\tconst end = () => {\n\t\t\tthis.timeElapsed = Date.now() - startTime;\n\t\t\treturn this.executor.emit('suiteEnd', this);\n\t\t};\n\n\t\t// Run the before and after suite lifecycle methods\n\t\tconst runLifecycleMethod = (\n\t\t\tsuite: Suite,\n\t\t\tname: keyof Suite,\n\t\t\ttest?: Test\n\t\t) => {\n\t\t\tlet result: PromiseLike<void> | undefined;\n\n\t\t\treturn new Task<void>(\n\t\t\t\t(resolve, reject) => {\n\t\t\t\t\tlet dfd: Deferred<any> | undefined;\n\t\t\t\t\tlet timeout: number | undefined;\n\n\t\t\t\t\t// Provide a new Suite#async method for each call of a\n\t\t\t\t\t// lifecycle method since there's no concept of a Suite-wide\n\t\t\t\t\t// async deferred as there is for Tests.\n\t\t\t\t\tsuite.async = function(_timeout?: number) {\n\t\t\t\t\t\ttimeout = _timeout;\n\n\t\t\t\t\t\tconst _dfd = new Deferred<any>();\n\t\t\t\t\t\tdfd = _dfd;\n\n\t\t\t\t\t\tsuite.async = function() {\n\t\t\t\t\t\t\treturn _dfd;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn _dfd;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst suiteFunc: SuiteLifecycleFunction = <any>suite[name];\n\n\t\t\t\t\t// Call the lifecycle function. The suite.async method above\n\t\t\t\t\t// may be called within this function call. If `test` is\n\t\t\t\t\t// defined (i.e., this is beforeEach or afterEach), pass it\n\t\t\t\t\t// first, followed by the suite. If `test` is not defined,\n\t\t\t\t\t// just pass the suite. This ordering is maintain backwards\n\t\t\t\t\t// compatibility with previous versions of Intern.\n\t\t\t\t\tresult =\n\t\t\t\t\t\tsuiteFunc &&\n\t\t\t\t\t\t(test\n\t\t\t\t\t\t\t? suiteFunc.call(suite, test, suite)\n\t\t\t\t\t\t\t: suiteFunc.call(suite, suite));\n\n\t\t\t\t\t// If dfd is set, it means the async method was called\n\t\t\t\t\tif (dfd) {\n\t\t\t\t\t\t// Assign to a const so TS knows it's defined\n\t\t\t\t\t\tconst _dfd = dfd;\n\n\t\t\t\t\t\t// If a timeout was set, async was called, so we should\n\t\t\t\t\t\t// use the dfd created by the call to manage the\n\t\t\t\t\t\t// timeout.\n\t\t\t\t\t\tif (timeout) {\n\t\t\t\t\t\t\tlet timer = setTimeout(function() {\n\t\t\t\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t\t\t\t`Timeout reached on ${suite.id}#${name}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\terror.name = 'TimeoutError';\n\t\t\t\t\t\t\t\t_dfd.reject(error);\n\t\t\t\t\t\t\t}, timeout);\n\n\t\t\t\t\t\t\t_dfd.promise\n\t\t\t\t\t\t\t\t.catch(_error => {})\n\t\t\t\t\t\t\t\t.then(() => timer && clearTimeout(timer));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the return value looks like a promise, resolve the\n\t\t\t\t\t\t// dfd if the return value resolves\n\t\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\t\tresult.then(\n\t\t\t\t\t\t\t\t() => _dfd.resolve(),\n\t\t\t\t\t\t\t\terror => _dfd.reject(error)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use the dfd.promise as the final result\n\t\t\t\t\t\tresult = dfd.promise;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\tresult.then(() => resolve(), reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tif (isTask(result)) {\n\t\t\t\t\t\tresult.cancel();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t\t\t.finally(() => {\n\t\t\t\t\t// Remove the async method since it should only be available\n\t\t\t\t\t// within a lifecycle function call\n\t\t\t\t\tsuite.async = undefined;\n\t\t\t\t})\n\t\t\t\t.catch((error: InternError) => {\n\t\t\t\t\tif (error !== SKIP) {\n\t\t\t\t\t\tif (!this.error) {\n\t\t\t\t\t\t\tthis.executor.log(\n\t\t\t\t\t\t\t\t'Suite errored with non-skip error',\n\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.error = error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t};\n\n\t\t// Convenience method to run 'before' suite lifecycle method\n\t\tconst before = () => {\n\t\t\treturn runLifecycleMethod(this, 'before');\n\t\t};\n\n\t\t// Convenience method to run the 'after' suite lifecycle method\n\t\tconst after = () => {\n\t\t\treturn runLifecycleMethod(this, 'after');\n\t\t};\n\n\t\t// Reset some state in case someone tries to re-run the same suite\n\t\t// TODO: Cancel any previous outstanding suite run\n\t\t// TODO: Test\n\t\tthis.error = undefined;\n\t\tthis.timeElapsed = 0;\n\n\t\tlet task: Task<void>;\n\t\tlet runTask: Task<void>;\n\n\t\ttry {\n\t\t\ttask = this.publishAfterSetup\n\t\t\t\t? before().then(start)\n\t\t\t\t: start().then(before);\n\t\t} catch (error) {\n\t\t\treturn Task.reject<void>(error);\n\t\t}\n\n\t\t// The task that manages running this suite's tests\n\t\treturn task\n\t\t\t.then(() => {\n\t\t\t\t// Run the beforeEach or afterEach methods for a given test in\n\t\t\t\t// the proper order based on the current nested Suite structure\n\t\t\t\tconst runTestLifecycle = (name: keyof Suite, test: Test) => {\n\t\t\t\t\tlet methodQueue: Suite[] = [];\n\t\t\t\t\tlet suite: Suite = this;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (name === 'beforeEach') {\n\t\t\t\t\t\t\t// beforeEach executes in order parent -> child;\n\t\t\t\t\t\t\tmethodQueue.push(suite);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// afterEach executes in order child -> parent\n\t\t\t\t\t\t\tmethodQueue.unshift(suite);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ((suite = suite.parent!));\n\n\t\t\t\t\tlet currentMethod: Task<any>;\n\n\t\t\t\t\treturn new Task(\n\t\t\t\t\t\t(resolve, reject) => {\n\t\t\t\t\t\t\tlet firstError: Error;\n\n\t\t\t\t\t\t\tconst handleError = (error: Error) => {\n\t\t\t\t\t\t\t\t// Note that a SKIP error will only be treated\n\t\t\t\t\t\t\t\t// as a 'skip' when thrown from beforeEach. If\n\t\t\t\t\t\t\t\t// thrown from afterEach it will be a suite\n\t\t\t\t\t\t\t\t// error.\n\t\t\t\t\t\t\t\tif (name === 'afterEach') {\n\t\t\t\t\t\t\t\t\tfirstError = firstError || error;\n\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst next = () => {\n\t\t\t\t\t\t\t\tconst suite = methodQueue.pop();\n\n\t\t\t\t\t\t\t\tif (!suite) {\n\t\t\t\t\t\t\t\t\tfirstError ? reject(firstError) : resolve();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrentMethod = runLifecycleMethod(\n\t\t\t\t\t\t\t\t\tsuite,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\ttest\n\t\t\t\t\t\t\t\t).then(next, handleError);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\tmethodQueue.splice(0, methodQueue.length);\n\t\t\t\t\t\t\tif (currentMethod) {\n\t\t\t\t\t\t\t\tcurrentMethod.cancel();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tlet i = 0;\n\t\t\t\tlet tests = this.tests;\n\t\t\t\tlet current: Task<void>;\n\n\t\t\t\t// Run each of the tests in this suite\n\t\t\t\trunTask = new Task<void>(\n\t\t\t\t\t(resolve, reject) => {\n\t\t\t\t\t\tlet firstError: Error;\n\t\t\t\t\t\tlet testTask: Task<void> | undefined;\n\n\t\t\t\t\t\tconst next = () => {\n\t\t\t\t\t\t\tconst test = tests[i++];\n\n\t\t\t\t\t\t\t// The task is over when there are no more tests to\n\t\t\t\t\t\t\t// run\n\t\t\t\t\t\t\tif (!test) {\n\t\t\t\t\t\t\t\tfirstError ? reject(firstError) : resolve();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst handleError = (error: InternError) => {\n\t\t\t\t\t\t\t\t// An error may be associated with a deeper test\n\t\t\t\t\t\t\t\t// already, in which case we do not want to\n\t\t\t\t\t\t\t\t// reassociate it with a more generic parent\n\t\t\t\t\t\t\t\tif (error && error.relatedTest == null) {\n\t\t\t\t\t\t\t\t\terror.relatedTest = <Test>test;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst runTest = () => {\n\t\t\t\t\t\t\t\t// Errors raised when running child tests should\n\t\t\t\t\t\t\t\t// be reported but should not cause this suite’s\n\t\t\t\t\t\t\t\t// run to reject, since this suite itself has\n\t\t\t\t\t\t\t\t// not failed.\n\t\t\t\t\t\t\t\tconst result = test.run().catch(error => {\n\t\t\t\t\t\t\t\t\thandleError(error);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\ttestTask = new Task<void>(\n\t\t\t\t\t\t\t\t\tresolve => {\n\t\t\t\t\t\t\t\t\t\tresult.then(resolve);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tresult.cancel();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn testTask;\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// If the suite will be skipped, mark the current\n\t\t\t\t\t\t\t// test as skipped. This will skip both individual\n\t\t\t\t\t\t\t// tests and nested suites.\n\t\t\t\t\t\t\tif (this.skipped != null) {\n\t\t\t\t\t\t\t\ttest.skipped = this.skipped;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// test is a suite\n\t\t\t\t\t\t\tif (isSuite(test)) {\n\t\t\t\t\t\t\t\tcurrent = runTest();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// test is a single test\n\t\t\t\t\t\t\t\tif (!this.grep.test(test.id)) {\n\t\t\t\t\t\t\t\t\ttest.skipped = 'grep';\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (test.skipped != null) {\n\t\t\t\t\t\t\t\t\tcurrent = this.executor.emit(\n\t\t\t\t\t\t\t\t\t\t'testEnd',\n\t\t\t\t\t\t\t\t\t\ttest\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcurrent = runTestLifecycle(\n\t\t\t\t\t\t\t\t\t\t'beforeEach',\n\t\t\t\t\t\t\t\t\t\ttest\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t\t\t\t\t// A test may have been skipped in a\n\t\t\t\t\t\t\t\t\t\t\t// beforeEach call\n\t\t\t\t\t\t\t\t\t\t\tif (test.skipped != null) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.executor.emit(\n\t\t\t\t\t\t\t\t\t\t\t\t\t'testEnd',\n\t\t\t\t\t\t\t\t\t\t\t\t\ttest\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\treturn runTest();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.finally(() => {\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\ttestTask &&\n\t\t\t\t\t\t\t\t\t\t\t\ttestTask.state === State.Pending\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\ttestTask.cancel();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\ttestTask = undefined;\n\t\t\t\t\t\t\t\t\t\t\treturn runTestLifecycle(\n\t\t\t\t\t\t\t\t\t\t\t\t'afterEach',\n\t\t\t\t\t\t\t\t\t\t\t\ttest\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.catch(error => {\n\t\t\t\t\t\t\t\t\t\t\tfirstError = firstError || error;\n\t\t\t\t\t\t\t\t\t\t\treturn handleError(error);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrent.then(() => {\n\t\t\t\t\t\t\t\tconst skipRestOfSuite = () => {\n\t\t\t\t\t\t\t\t\tthis.skipped =\n\t\t\t\t\t\t\t\t\t\tthis.skipped != null\n\t\t\t\t\t\t\t\t\t\t\t? this.skipped\n\t\t\t\t\t\t\t\t\t\t\t: BAIL_REASON;\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// If the test was a suite and the suite was\n\t\t\t\t\t\t\t\t// skipped due to bailing, skip the rest of this\n\t\t\t\t\t\t\t\t// suite\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisSuite(test) &&\n\t\t\t\t\t\t\t\t\ttest.skipped === BAIL_REASON\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tskipRestOfSuite();\n\t\t\t\t\t\t\t\t} else if (test.error && this.bail) {\n\t\t\t\t\t\t\t\t\t// If the test errored and bail mode is\n\t\t\t\t\t\t\t\t\t// enabled, skip the rest of this suite\n\t\t\t\t\t\t\t\t\tskipRestOfSuite();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\t// Ensure no more tests will run\n\t\t\t\t\t\ti = Infinity;\n\t\t\t\t\t\tif (current) {\n\t\t\t\t\t\t\tcurrent.cancel();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\treturn runTask;\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\tif (runTask && runTask.state === State.Pending) {\n\t\t\t\t\trunTask.cancel();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.finally(() => (this.publishAfterSetup ? end() : after()))\n\t\t\t.finally(() => (this.publishAfterSetup ? after() : end()));\n\t}\n\n\t/**\n\t * Skips this suite.\n\t *\n\t * Calling this function will cause all remaining tests in the suite to be\n\t * skipped. If a message was provided, a reporter may report the suite’s\n\t * tests as skipped. Skipped tests are not treated as passing or failing.\n\t *\n\t * If this method is called from a test function (as this.parent.skip()),\n\t * the test will be immediately halted, just as if the test’s own skip\n\t * method were called.\n\t *\n\t * @param message If provided, will be stored in this suite's `skipped` property.\n\t */\n\tskip(message: string = 'suite skipped') {\n\t\tthis.skipped = message;\n\t\t// Use the SKIP constant from Test so that calling Suite#skip from a\n\t\t// test won't fail the test.\n\t\tthrow SKIP;\n\t}\n\n\ttoJSON(): object {\n\t\tconst json: { [key: string]: any } = {\n\t\t\thasParent: Boolean(this.parent),\n\t\t\ttests: this.tests.map(test => test.toJSON())\n\t\t};\n\t\tconst properties: (keyof Suite)[] = [\n\t\t\t'name',\n\t\t\t'id',\n\t\t\t'parentId',\n\t\t\t'sessionId',\n\t\t\t'timeElapsed',\n\t\t\t'numTests',\n\t\t\t'numPassedTests',\n\t\t\t'numFailedTests',\n\t\t\t'numSkippedTests',\n\t\t\t'skipped'\n\t\t];\n\n\t\tproperties.forEach(key => {\n\t\t\tconst value = this[key];\n\t\t\tif (typeof value !== 'undefined') {\n\t\t\t\tjson[key] = value;\n\t\t\t}\n\t\t});\n\n\t\tif (this.error) {\n\t\t\tjson.error = {\n\t\t\t\tname: this.error.name,\n\t\t\t\tmessage: this.error.message,\n\t\t\t\tstack: this.error.stack\n\t\t\t};\n\n\t\t\tif (\n\t\t\t\tthis.error.relatedTest &&\n\t\t\t\tthis.error.relatedTest !== <any>this\n\t\t\t) {\n\t\t\t\t// relatedTest can be the Suite itself in the case of nested\n\t\t\t\t// suites (a nested Suite's error is caught by a parent Suite,\n\t\t\t\t// which assigns the nested Suite as the relatedTest, resulting\n\t\t\t\t// in nestedSuite.relatedTest === nestedSuite); in that case,\n\t\t\t\t// don't serialize it\n\t\t\t\tjson.error.relatedTest = this.error.relatedTest.toJSON();\n\t\t\t}\n\t\t}\n\n\t\treturn json;\n\t}\n}\n\nexport function isSuite(value: any): value is Suite {\n\treturn Array.isArray(value.tests) && typeof value.hasParent === 'boolean';\n}\n\nexport interface SuiteLifecycleFunction {\n\t(this: Suite, suite: Suite): void | PromiseLike<any>;\n}\n\nexport interface TestLifecycleFunction {\n\t(this: Suite, test: Test, suite: Suite): void | PromiseLike<any>;\n}\n\n/**\n * Properties that can be set on a Suite.\n *\n * Note that 'tests' isn't included so that other interfaces, such as the object\n * interface, can use a different definition for it.\n */\nexport interface SuiteProperties {\n\tafter: SuiteLifecycleFunction | undefined;\n\tafterEach: TestLifecycleFunction | undefined;\n\tbail: boolean | undefined;\n\tbefore: SuiteLifecycleFunction | undefined;\n\tbeforeEach: TestLifecycleFunction | undefined;\n\tgrep: RegExp;\n\tname: string | undefined;\n\tpublishAfterSetup: boolean;\n\ttimeout: number;\n}\n\n/**\n * Options that can be passed into a Suite constructor to initialize a suite\n */\nexport type SuiteOptions = Partial<SuiteProperties> & {\n\tname: string;\n\tparent: Suite;\n\ttests?: (Suite | Test)[];\n};\n\n/**\n * Options that can be passed into a Suite constructor to initialize a root\n * suite\n */\nexport type RootSuiteOptions = Partial<SuiteProperties> & {\n\texecutor: Executor;\n\ttests?: (Suite | Test)[];\n};\n\n// BAIL_REASON needs to be a string so that Intern can tell when a remote has\n// bailed during unit tests so that it can skip functional tests.\nconst BAIL_REASON = 'bailed';\n"]}